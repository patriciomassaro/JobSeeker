name: Build, Push to ECR, and Deploy to ECS

on:
  push:
    branches: 
      - dev

jobs:
  build-and-deploy-app:
    runs-on: self-hosted  
    environment: DEV 

    env: 
      POSTGRES_SERVER: ${{ secrets.POSTGRES_SERVER }}
      POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
      POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
      POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
      POSTGRES_PORT: ${{ secrets.POSTGRES_PORT }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      FIRST_SUPERUSER: ${{ secrets.FIRST_SUPERUSER }}
      FIRST_SUPERUSER_PASSWORD: ${{ secrets.FIRST_SUPERUSER_PASSWORD }}
      PROJECT_NAME: ${{ secrets.PROJECT_NAME }}
      ENVIRONMENT: ${{ secrets.ENVIRONMENT }}
      ECR_REPOSITORY_BACKEND: dev-${{ secrets.PROJECT_NAME }}-backend
      ECR_REPOSITORY_FRONTEND: dev-${{ secrets.PROJECT_NAME }}-frontend
      ECS_CLUSTER: dev-${{ secrets.PROJECT_NAME }}-cluster
      ECS_SERVICE: dev-${{ secrets.PROJECT_NAME }}-service
      ECS_TASK_DEFINITION: dev-${{ secrets.PROJECT_NAME }}-task
      CONTAINER_NAME: dev-${{ secrets.PROJECT_NAME }}-container

    steps:
    - name: Install Docker and Docker Compose
      run: |
        sudo dnf update -y
        sudo dnf install docker -y
        sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.3/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        sudo systemctl start docker
        sudo systemctl enable docker
        sudo usermod -aG docker $USER
        sudo chown $USER:docker /var/run/docker.sock
        sudo chmod +x /usr/local/bin/docker-compose
        docker --version
        docker-compose --version
        docker version

    - name: Checkout code
      uses: actions/checkout@v2

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Build, tag, and push images to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        # Backend
        docker-compose build backend
        docker tag ${PROJECT_NAME}-backend:${TAG} ${ECR_REGISTRY}/${ECR_REPOSITORY_BACKEND}:${TAG}
        docker push ${ECR_REGISTRY}/${ECR_REPOSITORY_BACKEND}:${TAG}

        # Frontend
        docker-compose build frontend
        docker tag ${PROJECT_NAME}-frontend:${TAG} ${ECR_REGISTRY}/${ECR_REPOSITORY_FRONTEND}:${TAG}
        docker push ${ECR_REGISTRY}/${ECR_REPOSITORY_FRONTEND}:${TAG}

    - name: Deploy Network Stack
      run: |
        aws cloudformation deploy \
          --template-file infrastructure/network-resources.yml \
          --stack-name ${ENVIRONMENT}-${PROJECT_NAME}-network \
          --parameter-overrides \
            EnvironmentName=${ENVIRONMENT} \
            ProjectName=${PROJECT_NAME} \
          --capabilities CAPABILITY_IAM

    - name: Create ECS Cluster
      run: |
        aws ecs create-cluster \
          --cluster-name ${ECS_CLUSTER} \
          --capacity-providers FARGATE \
          --default-capacity-provider-strategy capacityProvider=FARGATE,weight=1

    - name: Create Task Definition
      run: |
        task_def=$(cat <<EOF
        {
          "family": "${ECS_TASK_DEFINITION}",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "256",
          "memory": "512",
          "containerDefinitions": [
            {
              "name": "${CONTAINER_NAME}",
              "image": "${ECR_REGISTRY}/${ECR_REPOSITORY_BACKEND}:${TAG}",
              "portMappings": [
                {
                  "containerPort": 80,
                  "hostPort": 80,
                  "protocol": "tcp"
                }
              ],
              "environment": [
                {"name": "POSTGRES_SERVER", "value": "${POSTGRES_SERVER}"},
                {"name": "POSTGRES_USER", "value": "${POSTGRES_USER}"},
                {"name": "POSTGRES_PASSWORD", "value": "${POSTGRES_PASSWORD}"},
                {"name": "POSTGRES_DB", "value": "${POSTGRES_DB}"},
                {"name": "POSTGRES_PORT", "value": "${POSTGRES_PORT}"},
                {"name": "FIRST_SUPERUSER", "value": "${FIRST_SUPERUSER}"},
                {"name": "FIRST_SUPERUSER_PASSWORD", "value": "${FIRST_SUPERUSER_PASSWORD}"},
                {"name": "PROJECT_NAME", "value": "${PROJECT_NAME}"},
                {"name": "ENVIRONMENT", "value": "${ENVIRONMENT}"}
              ]
            }
          ]
        }
        EOF
        )
        echo "$task_def" > task-definition.json
        aws ecs register-task-definition --cli-input-json file://task-definition.json

    - name: Create or Update Load Balancer
      run: |
        VPC_ID=$(aws cloudformation describe-stacks --stack-name ${ENVIRONMENT}-${PROJECT_NAME}-network --query "Stacks[0].Outputs[?OutputKey=='VpcId'].OutputValue" --output text)
        SUBNET_1=$(aws cloudformation describe-stacks --stack-name ${ENVIRONMENT}-${PROJECT_NAME}-network --query "Stacks[0].Outputs[?OutputKey=='PublicSubnet1'].OutputValue" --output text)
        SUBNET_2=$(aws cloudformation describe-stacks --stack-name ${ENVIRONMENT}-${PROJECT_NAME}-network --query "Stacks[0].Outputs[?OutputKey=='PublicSubnet2'].OutputValue" --output text)
        SECURITY_GROUP=$(aws cloudformation describe-stacks --stack-name ${ENVIRONMENT}-${PROJECT_NAME}-network --query "Stacks[0].Outputs[?OutputKey=='ECSSecurityGroup'].OutputValue" --output text)

        LB_NAME="${ENVIRONMENT}-${PROJECT_NAME}-alb"
        LB_ARN=$(aws elbv2 describe-load-balancers --names $LB_NAME --query 'LoadBalancers[0].LoadBalancerArn' --output text 2>/dev/null || echo "")
        if [ -z "$LB_ARN" ] || [ "$LB_ARN" == "None" ]; then
          echo "Creating new load balancer: $LB_NAME"
          LB_ARN=$(aws elbv2 create-load-balancer \
            --name $LB_NAME \
            --subnets $SUBNET_1 $SUBNET_2 \
            --security-groups $SECURITY_GROUP \
            --query 'LoadBalancers[0].LoadBalancerArn' \
            --output text)
        else
          echo "Load balancer already exists: $LB_NAME"
        fi

        TG_NAME="${ENVIRONMENT}-${PROJECT_NAME}-tg"
        TG_ARN=$(aws elbv2 describe-target-groups --names $TG_NAME --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || echo "")
        if [ -z "$TG_ARN" ] || [ "$TG_ARN" == "None" ]; then
          echo "Creating new target group: $TG_NAME"
          TG_ARN=$(aws elbv2 create-target-group \
            --name $TG_NAME \
            --protocol HTTP \
            --port 80 \
            --vpc-id $VPC_ID \
            --target-type ip \
            --query 'TargetGroups[0].TargetGroupArn' \
            --output text)
        else
          echo "Target group already exists: $TG_NAME"
        fi

        LISTENER_ARN=$(aws elbv2 describe-listeners --load-balancer-arn $LB_ARN --query 'Listeners[0].ListenerArn' --output text 2>/dev/null || echo "")
        if [ -z "$LISTENER_ARN" ] || [ "$LISTENER_ARN" == "None" ]; then
          echo "Creating new listener for load balancer"
          aws elbv2 create-listener \
            --load-balancer-arn $LB_ARN \
            --protocol HTTP \
            --port 80 \
            --default-actions Type=forward,TargetGroupArn=$TG_ARN
        else
          echo "Listener already exists for load balancer"
        fi

        echo "LB_ARN=$LB_ARN" >> $GITHUB_ENV
        echo "TG_ARN=$TG_ARN" >> $GITHUB_ENV

    - name: Create or Update ECS Service
      run: |
        SUBNET_1=$(aws cloudformation describe-stacks --stack-name ${ENVIRONMENT}-${PROJECT_NAME}-network --query "Stacks[0].Outputs[?OutputKey=='PublicSubnet1'].OutputValue" --output text)
        SUBNET_2=$(aws cloudformation describe-stacks --stack-name ${ENVIRONMENT}-${PROJECT_NAME}-network --query "Stacks[0].Outputs[?OutputKey=='PublicSubnet2'].OutputValue" --output text)
        SECURITY_GROUP=$(aws cloudformation describe-stacks --stack-name ${ENVIRONMENT}-${PROJECT_NAME}-network --query "Stacks[0].Outputs[?OutputKey=='ECSSecurityGroup'].OutputValue" --output text)

        if aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE --query "services[?status=='ACTIVE']" --output text | grep -q .; then
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --task-definition $ECS_TASK_DEFINITION \
            --desired-count 1 \
            --force-new-deployment
        else
          aws ecs create-service \
            --cluster $ECS_CLUSTER \
            --service-name $ECS_SERVICE \
            --task-definition $ECS_TASK_DEFINITION \
            --desired-count 1 \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_1,$SUBNET_2],securityGroups=[$SECURITY_GROUP],assignPublicIp=ENABLED}" \
            --load-balancers "targetGroupArn=$TG_ARN,containerName=$CONTAINER_NAME,containerPort=80"
        fi

    - name: Get Load Balancer DNS Name
      run: |
        LB_DNS=$(aws elbv2 describe-load-balancers --load-balancer-arns $LB_ARN --query 'LoadBalancers[0].DNSName' --output text)
        echo "Your API is accessible at: http://$LB_DNS"
        echo "LB_DNS=$LB_DNS" >> $GITHUB_ENV

    - name: Cleanup
      if: always()
      run: |
        docker-compose down
        docker system prune -af
