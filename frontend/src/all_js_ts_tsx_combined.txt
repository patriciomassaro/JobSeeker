===== ./utils.ts =====
export const emailPattern = {
  value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i,
  message: "Invalid email address",
}

export const namePattern = {
  value: /^[A-Za-z\s\u00C0-\u017F]{1,30}$/,
  message: "Invalid name",
}

export const passwordRules = (isRequired = true) => {
  const rules: any = {
    minLength: {
      value: 8,
      message: "Password must be at least 8 characters",
    },
  }

  if (isRequired) {
    rules.required = "Password is required"
  }

  return rules
}

export const confirmPasswordRules = (
  getValues: () => any,
  isRequired = true,
) => {
  const rules: any = {
    validate: (value: string) => {
      const password = getValues().password || getValues().new_password
      return value === password ? true : "The passwords do not match"
    },
  }

  if (isRequired) {
    rules.required = "Password confirmation is required";
  }

  return rules;
}

===== ./vite-env.d.ts =====
/// <reference types="vite/client" />

===== ./hooks/useCustomToast.ts =====
import { useToast } from "@chakra-ui/react"
import { useCallback } from "react"

const useCustomToast = () => {
  const toast = useToast()

  const showToast = useCallback(
    (title: string, description: string, status: "success" | "error") => {
      toast({
        title,
        description,
        status,
        isClosable: true,
        position: "bottom-right",
      })
    },
    [toast],
  )

  return showToast
}

export default useCustomToast

===== ./hooks/useAuth.ts =====
import { useMutation, useQuery } from "@tanstack/react-query"
import { useNavigate } from "@tanstack/react-router"
import { useState } from "react"

import { AxiosError } from "axios"
import {
  type Body_login_login_access_token as AccessToken,
  type ApiError,
  LoginService,
  type UserPublicMe,
  UsersService,
} from "../client"

const isLoggedIn = () => {
  return localStorage.getItem("access_token") !== null
}

const useAuth = () => {
  const [error, setError] = useState<string | null>(null)
  const navigate = useNavigate()
  const { data: user, isLoading } = useQuery<UserPublicMe | null, Error>({
    queryKey: ["currentUser"],
    queryFn: UsersService.readUserMe,
    enabled: isLoggedIn(),
  })

  const login = async (data: AccessToken) => {
    const response = await LoginService.loginAccessToken({
      formData: data,
    })
    localStorage.setItem("access_token", response.access_token)
  }

  const loginMutation = useMutation({
    mutationFn: login,
    onSuccess: () => {
      navigate({ to: "/" })
    },
    onError: (err: ApiError) => {
      let errDetail = (err.body as any)?.detail

      if (err instanceof AxiosError) {
        errDetail = err.message
      }

      if (Array.isArray(errDetail)) {
        errDetail = "Something went wrong"
      }

      setError(errDetail)
    },
  })

  const logout = () => {
    localStorage.removeItem("access_token")
    navigate({ to: "/login" })
  }

  return {
    loginMutation,
    logout,
    user,
    isLoading,
    error,
    resetError: () => setError(null),
  }
}

export { isLoggedIn }
export default useAuth

===== ./routeTree.gen.ts =====
/* prettier-ignore-start */

/* eslint-disable */

// @ts-nocheck

// noinspection JSUnusedGlobalSymbols

// This file is auto-generated by TanStack Router

// Import Routes

import { Route as rootRoute } from './routes/__root'
import { Route as ResetPasswordImport } from './routes/reset-password'
import { Route as RecoverPasswordImport } from './routes/recover-password'
import { Route as LoginImport } from './routes/login'
import { Route as LayoutImport } from './routes/_layout'
import { Route as LayoutIndexImport } from './routes/_layout/index'
import { Route as LayoutSettingsImport } from './routes/_layout/settings'
import { Route as LayoutJobpostingsImport } from './routes/_layout/jobpostings'
import { Route as LayoutComparisonsImport } from './routes/_layout/comparisons'
import { Route as LayoutAdminImport } from './routes/_layout/admin'

// Create/Update Routes

const ResetPasswordRoute = ResetPasswordImport.update({
  path: '/reset-password',
  getParentRoute: () => rootRoute,
} as any)

const RecoverPasswordRoute = RecoverPasswordImport.update({
  path: '/recover-password',
  getParentRoute: () => rootRoute,
} as any)

const LoginRoute = LoginImport.update({
  path: '/login',
  getParentRoute: () => rootRoute,
} as any)

const LayoutRoute = LayoutImport.update({
  id: '/_layout',
  getParentRoute: () => rootRoute,
} as any)

const LayoutIndexRoute = LayoutIndexImport.update({
  path: '/',
  getParentRoute: () => LayoutRoute,
} as any)

const LayoutSettingsRoute = LayoutSettingsImport.update({
  path: '/settings',
  getParentRoute: () => LayoutRoute,
} as any)

const LayoutJobpostingsRoute = LayoutJobpostingsImport.update({
  path: '/jobpostings',
  getParentRoute: () => LayoutRoute,
} as any)

const LayoutComparisonsRoute = LayoutComparisonsImport.update({
  path: '/comparisons',
  getParentRoute: () => LayoutRoute,
} as any)

const LayoutAdminRoute = LayoutAdminImport.update({
  path: '/admin',
  getParentRoute: () => LayoutRoute,
} as any)

// Populate the FileRoutesByPath interface

declare module '@tanstack/react-router' {
  interface FileRoutesByPath {
    '/_layout': {
      preLoaderRoute: typeof LayoutImport
      parentRoute: typeof rootRoute
    }
    '/login': {
      preLoaderRoute: typeof LoginImport
      parentRoute: typeof rootRoute
    }
    '/recover-password': {
      preLoaderRoute: typeof RecoverPasswordImport
      parentRoute: typeof rootRoute
    }
    '/reset-password': {
      preLoaderRoute: typeof ResetPasswordImport
      parentRoute: typeof rootRoute
    }
    '/_layout/admin': {
      preLoaderRoute: typeof LayoutAdminImport
      parentRoute: typeof LayoutImport
    }
    '/_layout/comparisons': {
      preLoaderRoute: typeof LayoutComparisonsImport
      parentRoute: typeof LayoutImport
    }
    '/_layout/jobpostings': {
      preLoaderRoute: typeof LayoutJobpostingsImport
      parentRoute: typeof LayoutImport
    }
    '/_layout/settings': {
      preLoaderRoute: typeof LayoutSettingsImport
      parentRoute: typeof LayoutImport
    }
    '/_layout/': {
      preLoaderRoute: typeof LayoutIndexImport
      parentRoute: typeof LayoutImport
    }
  }
}

// Create and export the route tree

export const routeTree = rootRoute.addChildren([
  LayoutRoute.addChildren([
    LayoutAdminRoute,
    LayoutComparisonsRoute,
    LayoutJobpostingsRoute,
    LayoutSettingsRoute,
    LayoutIndexRoute,
  ]),
  LoginRoute,
  RecoverPasswordRoute,
  ResetPasswordRoute,
])

/* prettier-ignore-end */

===== ./client/core/CancelablePromise.ts =====
export class CancelError extends Error {
	constructor(message: string) {
		super(message);
		this.name = 'CancelError';
	}

	public get isCancelled(): boolean {
		return true;
	}
}

export interface OnCancel {
	readonly isResolved: boolean;
	readonly isRejected: boolean;
	readonly isCancelled: boolean;

	(cancelHandler: () => void): void;
}

export class CancelablePromise<T> implements Promise<T> {
	private _isResolved: boolean;
	private _isRejected: boolean;
	private _isCancelled: boolean;
	readonly cancelHandlers: (() => void)[];
	readonly promise: Promise<T>;
	private _resolve?: (value: T | PromiseLike<T>) => void;
	private _reject?: (reason?: unknown) => void;

	constructor(
		executor: (
			resolve: (value: T | PromiseLike<T>) => void,
			reject: (reason?: unknown) => void,
			onCancel: OnCancel
		) => void
	) {
		this._isResolved = false;
		this._isRejected = false;
		this._isCancelled = false;
		this.cancelHandlers = [];
		this.promise = new Promise<T>((resolve, reject) => {
			this._resolve = resolve;
			this._reject = reject;

			const onResolve = (value: T | PromiseLike<T>): void => {
				if (this._isResolved || this._isRejected || this._isCancelled) {
					return;
				}
				this._isResolved = true;
				if (this._resolve) this._resolve(value);
			};

			const onReject = (reason?: unknown): void => {
				if (this._isResolved || this._isRejected || this._isCancelled) {
					return;
				}
				this._isRejected = true;
				if (this._reject) this._reject(reason);
			};

			const onCancel = (cancelHandler: () => void): void => {
				if (this._isResolved || this._isRejected || this._isCancelled) {
					return;
				}
				this.cancelHandlers.push(cancelHandler);
			};

			Object.defineProperty(onCancel, 'isResolved', {
				get: (): boolean => this._isResolved,
			});

			Object.defineProperty(onCancel, 'isRejected', {
				get: (): boolean => this._isRejected,
			});

			Object.defineProperty(onCancel, 'isCancelled', {
				get: (): boolean => this._isCancelled,
			});

			return executor(onResolve, onReject, onCancel as OnCancel);
		});
	}

	get [Symbol.toStringTag]() {
		return "Cancellable Promise";
	}

	public then<TResult1 = T, TResult2 = never>(
		onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
		onRejected?: ((reason: unknown) => TResult2 | PromiseLike<TResult2>) | null
	): Promise<TResult1 | TResult2> {
		return this.promise.then(onFulfilled, onRejected);
	}

	public catch<TResult = never>(
		onRejected?: ((reason: unknown) => TResult | PromiseLike<TResult>) | null
	): Promise<T | TResult> {
		return this.promise.catch(onRejected);
	}

	public finally(onFinally?: (() => void) | null): Promise<T> {
		return this.promise.finally(onFinally);
	}

	public cancel(): void {
		if (this._isResolved || this._isRejected || this._isCancelled) {
			return;
		}
		this._isCancelled = true;
		if (this.cancelHandlers.length) {
			try {
				for (const cancelHandler of this.cancelHandlers) {
					cancelHandler();
				}
			} catch (error) {
				console.warn('Cancellation threw an error', error);
				return;
			}
		}
		this.cancelHandlers.length = 0;
		if (this._reject) this._reject(new CancelError('Request aborted'));
	}

	public get isCancelled(): boolean {
		return this._isCancelled;
	}
}
===== ./client/core/ApiRequestOptions.ts =====
export type ApiRequestOptions = {
	readonly method: 'GET' | 'PUT' | 'POST' | 'DELETE' | 'OPTIONS' | 'HEAD' | 'PATCH';
	readonly url: string;
	readonly path?: Record<string, unknown>;
	readonly cookies?: Record<string, unknown>;
	readonly headers?: Record<string, unknown>;
	readonly query?: Record<string, unknown>;
	readonly formData?: Record<string, unknown>;
	readonly body?: any;
	readonly mediaType?: string;
	readonly responseHeader?: string;
	readonly errors?: Record<number, string>;
};
===== ./client/core/ApiResult.ts =====
export type ApiResult<TData = any> = {
	readonly body: TData;
	readonly ok: boolean;
	readonly status: number;
	readonly statusText: string;
	readonly url: string;
};
===== ./client/core/types.ts =====
import type { ApiResult } from './ApiResult';

export type TResult = 'body' | 'raw';

export type TApiResponse<T extends TResult, TData> =
  Exclude<T, 'raw'> extends never
    ? ApiResult<TData>
    : ApiResult<TData>['body'];

export type TConfig<T extends TResult> = {
  _result?: T;
};
===== ./client/core/request.ts =====
import axios from 'axios';
import type { AxiosError, AxiosRequestConfig, AxiosResponse, AxiosInstance } from 'axios';

import { ApiError } from './ApiError';
import type { ApiRequestOptions } from './ApiRequestOptions';
import type { ApiResult } from './ApiResult';
import { CancelablePromise } from './CancelablePromise';
import type { OnCancel } from './CancelablePromise';
import type { OpenAPIConfig } from './OpenAPI';

export const isString = (value: unknown): value is string => {
  return typeof value === 'string';
};

export const isStringWithValue = (value: unknown): value is string => {
  return isString(value) && value !== '';
};

export const isBlob = (value: any): value is Blob => {
  return value instanceof Blob;
};

export const isFormData = (value: unknown): value is FormData => {
  return value instanceof FormData;
};

export const isSuccess = (status: number): boolean => {
  return status >= 200 && status < 300;
};

export const base64 = (str: string): string => {
  try {
    return btoa(str);
  } catch (err) {
    // @ts-ignore
    return Buffer.from(str).toString('base64');
  }
};

export const getQueryString = (params: Record<string, unknown>): string => {
  const qs: string[] = [];

  const append = (key: string, value: unknown) => {
    qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
  };

  const encodePair = (key: string, value: unknown) => {
    if (value === undefined || value === null) {
      return;
    }

    if (Array.isArray(value)) {
      value.forEach(v => encodePair(key, v));
    } else if (typeof value === 'object') {
      Object.entries(value).forEach(([k, v]) => encodePair(`${key}[${k}]`, v));
    } else {
      append(key, value);
    }
  };

  Object.entries(params).forEach(([key, value]) => encodePair(key, value));

  return qs.length ? `?${qs.join('&')}` : '';
};

const getUrl = (config: OpenAPIConfig, options: ApiRequestOptions): string => {
  const encoder = config.ENCODE_PATH || encodeURI;

  const path = options.url
    .replace('{api-version}', config.VERSION)
    .replace(/{(.*?)}/g, (substring: string, group: string) => {
      if (options.path?.hasOwnProperty(group)) {
        return encoder(String(options.path[group]));
      }
      return substring;
    });

  const url = config.BASE + path;
  return options.query ? url + getQueryString(options.query) : url;
};

export const getFormData = (options: ApiRequestOptions): FormData | undefined => {
  if (options.formData) {
    const formData = new FormData();

    const process = (key: string, value: unknown) => {
      if (isString(value) || isBlob(value)) {
        formData.append(key, value);
      } else {
        formData.append(key, JSON.stringify(value));
      }
    };

    Object.entries(options.formData)
      .filter(([, value]) => value !== undefined && value !== null)
      .forEach(([key, value]) => {
        if (Array.isArray(value)) {
          value.forEach(v => process(key, v));
        } else {
          process(key, value);
        }
      });

    return formData;
  }
  return undefined;
};

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;

export const resolve = async <T>(options: ApiRequestOptions, resolver?: T | Resolver<T>): Promise<T | undefined> => {
  if (typeof resolver === 'function') {
    return (resolver as Resolver<T>)(options);
  }
  return resolver;
};

export const getHeaders = async (config: OpenAPIConfig, options: ApiRequestOptions): Promise<Record<string, string>> => {
  const [token, username, password, additionalHeaders] = await Promise.all([
    resolve(options, config.TOKEN),
    resolve(options, config.USERNAME),
    resolve(options, config.PASSWORD),
    resolve(options, config.HEADERS),
  ]);

  const headers = Object.entries({
    Accept: 'application/json',
    ...additionalHeaders,
    ...options.headers,
  })
    .filter(([, value]) => value !== undefined && value !== null)
    .reduce((headers, [key, value]) => ({
      ...headers,
      [key]: String(value),
    }), {} as Record<string, string>);

  if (isStringWithValue(token)) {
    headers['Authorization'] = `Bearer ${token}`;
  }

  if (isStringWithValue(username) && isStringWithValue(password)) {
    const credentials = base64(`${username}:${password}`);
    headers['Authorization'] = `Basic ${credentials}`;
  }

  if (options.body !== undefined) {
    if (options.mediaType) {
      headers['Content-Type'] = options.mediaType;
    } else if (isBlob(options.body)) {
      headers['Content-Type'] = options.body.type || 'application/octet-stream';
    } else if (isString(options.body)) {
      headers['Content-Type'] = 'text/plain';
    } else if (!isFormData(options.body)) {
      headers['Content-Type'] = 'application/json';
    }
  } else if (options.formData !== undefined) {
    if (options.mediaType) {
      headers['Content-Type'] = options.mediaType;
    }
  }

  return headers;
};

export const getRequestBody = (options: ApiRequestOptions): unknown => {
  if (options.body) {
    return options.body;
  }
  return undefined;
};

export const sendRequest = async <T>(
  config: OpenAPIConfig,
  options: ApiRequestOptions,
  url: string,
  body: unknown,
  formData: FormData | undefined,
  headers: Record<string, string>,
  onCancel: OnCancel,
  axiosClient: AxiosInstance
): Promise<AxiosResponse<T>> => {
  const controller = new AbortController();

  let requestConfig: AxiosRequestConfig = {
    data: body ?? formData,
    headers,
    method: options.method,
    signal: controller.signal,
    url,
    withCredentials: config.WITH_CREDENTIALS,
  };

  onCancel(() => controller.abort());

  for (const fn of config.interceptors.request._fns) {
    requestConfig = await fn(requestConfig)
  }

  try {
    return await axiosClient.request(requestConfig);
  } catch (error) {
    const axiosError = error as AxiosError<T>;
    if (axiosError.response) {
      return axiosError.response;
    }
    throw error;
  }
};

export const getResponseHeader = (response: AxiosResponse<unknown>, responseHeader?: string): string | undefined => {
  if (responseHeader) {
    const content = response.headers[responseHeader];
    if (isString(content)) {
      return content;
    }
  }
  return undefined;
};

export const getResponseBody = (response: AxiosResponse<unknown>): unknown => {
  if (response.status !== 204) {
    return response.data;
  }
  return undefined;
};

export const catchErrorCodes = (options: ApiRequestOptions, result: ApiResult): void => {
  const errors: Record<number, string> = {
    400: 'Bad Request',
    401: 'Unauthorized',
    402: 'Payment Required',
    403: 'Forbidden',
    404: 'Not Found',
    405: 'Method Not Allowed',
    406: 'Not Acceptable',
    407: 'Proxy Authentication Required',
    408: 'Request Timeout',
    409: 'Conflict',
    410: 'Gone',
    411: 'Length Required',
    412: 'Precondition Failed',
    413: 'Payload Too Large',
    414: 'URI Too Long',
    415: 'Unsupported Media Type',
    416: 'Range Not Satisfiable',
    417: 'Expectation Failed',
    418: 'Im a teapot',
    421: 'Misdirected Request',
    422: 'Unprocessable Content',
    423: 'Locked',
    424: 'Failed Dependency',
    425: 'Too Early',
    426: 'Upgrade Required',
    428: 'Precondition Required',
    429: 'Too Many Requests',
    431: 'Request Header Fields Too Large',
    451: 'Unavailable For Legal Reasons',
    500: 'Internal Server Error',
    501: 'Not Implemented',
    502: 'Bad Gateway',
    503: 'Service Unavailable',
    504: 'Gateway Timeout',
    505: 'HTTP Version Not Supported',
    506: 'Variant Also Negotiates',
    507: 'Insufficient Storage',
    508: 'Loop Detected',
    510: 'Not Extended',
    511: 'Network Authentication Required',
    ...options.errors,
  }

  const error = errors[result.status];
  if (error) {
    throw new ApiError(options, result, error);
  }

  if (!result.ok) {
    const errorStatus = result.status ?? 'unknown';
    const errorStatusText = result.statusText ?? 'unknown';
    const errorBody = (() => {
      try {
        return JSON.stringify(result.body, null, 2);
      } catch (e) {
        return undefined;
      }
    })();

    throw new ApiError(options, result,
      `Generic Error: status: ${errorStatus}; status text: ${errorStatusText}; body: ${errorBody}`
    );
  }
};

/**
 * Request method
 * @param config The OpenAPI configuration object
 * @param options The request options from the service
 * @param axiosClient The axios client instance to use
 * @returns CancelablePromise<T>
 * @throws ApiError
 */
export const request = <T>(config: OpenAPIConfig, options: ApiRequestOptions, axiosClient: AxiosInstance = axios): CancelablePromise<T> => {
  return new CancelablePromise(async (resolve, reject, onCancel) => {
    try {
      const url = getUrl(config, options);
      const formData = getFormData(options);
      const body = getRequestBody(options);
      console.log(url)
      console.log(body)
      const headers = await getHeaders(config, options);

      if (!onCancel.isCancelled) {
        let response = await sendRequest<T>(config, options, url, body, formData, headers, onCancel, axiosClient);

        for (const fn of config.interceptors.response._fns) {
          response = await fn(response)
        }

        const responseBody = getResponseBody(response);
        const responseHeader = getResponseHeader(response, options.responseHeader);

        const result: ApiResult = {
          url,
          ok: isSuccess(response.status),
          status: response.status,
          statusText: response.statusText,
          body: responseHeader ?? responseBody,
        };

        catchErrorCodes(options, result);

        resolve(result.body);
      }
    } catch (error) {
      reject(error);
    }
  });
};

===== ./client/core/ApiError.ts =====
import type { ApiRequestOptions } from './ApiRequestOptions';
import type { ApiResult } from './ApiResult';

export class ApiError extends Error {
	public readonly url: string;
	public readonly status: number;
	public readonly statusText: string;
	public readonly body: unknown;
	public readonly request: ApiRequestOptions;

	constructor(request: ApiRequestOptions, response: ApiResult, message: string) {
		super(message);

		this.name = 'ApiError';
		this.url = response.url;
		this.status = response.status;
		this.statusText = response.statusText;
		this.body = response.body;
		this.request = request;
	}
}
===== ./client/core/OpenAPI.ts =====
import type { AxiosRequestConfig, AxiosResponse } from 'axios';import type { ApiRequestOptions } from './ApiRequestOptions';
import type { TResult } from './types';

type Headers = Record<string, string>;
type Middleware<T> = (value: T) => T | Promise<T>;
type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;

export class Interceptors<T> {
  _fns: Middleware<T>[];

  constructor() {
    this._fns = [];
  }

  eject(fn: Middleware<T>) {
    const index = this._fns.indexOf(fn);
    if (index !== -1) {
      this._fns = [
        ...this._fns.slice(0, index),
        ...this._fns.slice(index + 1),
      ];
    }
  }

  use(fn: Middleware<T>) {
    this._fns = [...this._fns, fn];
  }
}

export type OpenAPIConfig = {
	BASE: string;
	CREDENTIALS: 'include' | 'omit' | 'same-origin';
	ENCODE_PATH?: ((path: string) => string) | undefined;
	HEADERS?: Headers | Resolver<Headers> | undefined;
	PASSWORD?: string | Resolver<string> | undefined;
	RESULT?: TResult;
	TOKEN?: string | Resolver<string> | undefined;
	USERNAME?: string | Resolver<string> | undefined;
	VERSION: string;
	WITH_CREDENTIALS: boolean;
	interceptors: {request: Interceptors<AxiosRequestConfig>;
		response: Interceptors<AxiosResponse>;};
};

export const OpenAPI: OpenAPIConfig = {
	BASE: '',
	CREDENTIALS: 'include',
	ENCODE_PATH: undefined,
	HEADERS: undefined,
	PASSWORD: undefined,
	RESULT: 'body',
	TOKEN: undefined,
	USERNAME: undefined,
	VERSION: '0.1.0',
	WITH_CREDENTIALS: false,
	interceptors: {request: new Interceptors(),response: new Interceptors(),
	},
};
===== ./client/schemas.ts =====
export const $Body_login_login_access_token = {
	properties: {
		grant_type: {
	type: 'any-of',
	contains: [{
	type: 'string',
	pattern: 'password',
}, {
	type: 'null',
}],
},
		username: {
	type: 'string',
	isRequired: true,
},
		password: {
	type: 'string',
	isRequired: true,
},
		scope: {
	type: 'string',
	default: '',
},
		client_id: {
	type: 'any-of',
	contains: [{
	type: 'string',
}, {
	type: 'null',
}],
},
		client_secret: {
	type: 'any-of',
	contains: [{
	type: 'string',
}, {
	type: 'null',
}],
},
	},
} as const;

export const $HTTPValidationError = {
	properties: {
		detail: {
	type: 'array',
	contains: {
		type: 'ValidationError',
	},
},
	},
} as const;

export const $ItemCreate = {
	properties: {
		title: {
	type: 'string',
	isRequired: true,
},
		description: {
	type: 'any-of',
	contains: [{
	type: 'string',
}, {
	type: 'null',
}],
},
	},
} as const;

export const $ItemPublic = {
	properties: {
		title: {
	type: 'string',
	isRequired: true,
},
		description: {
	type: 'any-of',
	contains: [{
	type: 'string',
}, {
	type: 'null',
}],
},
		id: {
	type: 'number',
	isRequired: true,
},
		owner_id: {
	type: 'number',
	isRequired: true,
},
	},
} as const;

export const $ItemUpdate = {
	properties: {
		title: {
	type: 'any-of',
	contains: [{
	type: 'string',
}, {
	type: 'null',
}],
},
		description: {
	type: 'any-of',
	contains: [{
	type: 'string',
}, {
	type: 'null',
}],
},
	},
} as const;

export const $ItemsPublic = {
	properties: {
		data: {
	type: 'array',
	contains: {
		type: 'ItemPublic',
	},
	isRequired: true,
},
		count: {
	type: 'number',
	isRequired: true,
},
	},
} as const;

export const $Message = {
	properties: {
		message: {
	type: 'string',
	isRequired: true,
},
	},
} as const;

export const $NewPassword = {
	properties: {
		token: {
	type: 'string',
	isRequired: true,
},
		new_password: {
	type: 'string',
	isRequired: true,
},
	},
} as const;

export const $Token = {
	properties: {
		access_token: {
	type: 'string',
	isRequired: true,
},
		token_type: {
	type: 'string',
	default: 'bearer',
},
	},
} as const;

export const $UpdatePassword = {
	properties: {
		current_password: {
	type: 'string',
	isRequired: true,
},
		new_password: {
	type: 'string',
	isRequired: true,
},
	},
} as const;

export const $UserCreate = {
	properties: {
		email: {
	type: 'string',
	isRequired: true,
},
		is_active: {
	type: 'boolean',
	default: true,
},
		is_superuser: {
	type: 'boolean',
	default: false,
},
		full_name: {
	type: 'any-of',
	contains: [{
	type: 'string',
}, {
	type: 'null',
}],
},
		password: {
	type: 'string',
	isRequired: true,
},
	},
} as const;

export const $UserPublic = {
	properties: {
		email: {
	type: 'string',
	isRequired: true,
},
		is_active: {
	type: 'boolean',
	default: true,
},
		is_superuser: {
	type: 'boolean',
	default: false,
},
		full_name: {
	type: 'any-of',
	contains: [{
	type: 'string',
}, {
	type: 'null',
}],
},
		id: {
	type: 'number',
	isRequired: true,
},
	},
} as const;

export const $UserRegister = {
	properties: {
		email: {
	type: 'string',
	isRequired: true,
},
		password: {
	type: 'string',
	isRequired: true,
},
		full_name: {
	type: 'any-of',
	contains: [{
	type: 'string',
}, {
	type: 'null',
}],
},
	},
} as const;

export const $UserUpdate = {
	properties: {
		email: {
	type: 'any-of',
	contains: [{
	type: 'string',
}, {
	type: 'null',
}],
},
		is_active: {
	type: 'boolean',
	default: true,
},
		is_superuser: {
	type: 'boolean',
	default: false,
},
		full_name: {
	type: 'any-of',
	contains: [{
	type: 'string',
}, {
	type: 'null',
}],
},
		password: {
	type: 'any-of',
	contains: [{
	type: 'string',
}, {
	type: 'null',
}],
},
	},
} as const;

export const $UserUpdateMe = {
	properties: {
		full_name: {
	type: 'any-of',
	contains: [{
	type: 'string',
}, {
	type: 'null',
}],
},
		email: {
	type: 'any-of',
	contains: [{
	type: 'string',
}, {
	type: 'null',
}],
},
	},
} as const;

export const $UsersPublic = {
	properties: {
		data: {
	type: 'array',
	contains: {
		type: 'UserPublic',
	},
	isRequired: true,
},
		count: {
	type: 'number',
	isRequired: true,
},
	},
} as const;

export const $ValidationError = {
	properties: {
		loc: {
	type: 'array',
	contains: {
	type: 'any-of',
	contains: [{
	type: 'string',
}, {
	type: 'number',
}],
},
	isRequired: true,
},
		msg: {
	type: 'string',
	isRequired: true,
},
		type: {
	type: 'string',
	isRequired: true,
},
	},
} as const;
===== ./client/index.ts =====

export { ApiError } from './core/ApiError';
export { CancelablePromise, CancelError } from './core/CancelablePromise';
export { OpenAPI } from './core/OpenAPI';
export type { OpenAPIConfig } from './core/OpenAPI';

export * from './models'
export * from './schemas'
export * from './services'

===== ./client/models.ts =====
export type Body_login_login_access_token = {
  grant_type?: string | null;
  username: string;
  password: string;
  scope?: string;
  client_id?: string | null;
  client_secret?: string | null;
};



export type HTTPValidationError = {
  detail?: Array<ValidationError>;
};


export type Message = {
  message: string;
};



export type NewPassword = {
  token: string;
  new_password: string;
};



export type Token = {
  access_token: string;
  token_type?: string;
};



export type UpdatePassword = {
  current_password: string;
  new_password: string;
};



export type UserCreate = {
  email: string;
  is_active?: boolean;
  is_superuser?: boolean;
  full_name?: string | null;
  password: string;
};



export type UserPublicMe = {
  username: string
  name: string;
  id: number;
  date_created: Date;
  date_updated: Date;
  parsed_personal?: Record<string, any>; // `dict` in Python corresponds to an object in TypeScript
  parsed_work_experiences?: Record<string, any>;
  parsed_educations?: Record<string, any>;
  parsed_languages?: Record<string, any>;
  parsed_skills?: string[]; // List in Python translates directly to array in TypeScript
  additional_info?: string;
  resume?: string;
  is_superuser: boolean;
};




export type UserRegister = {
  email: string;
  password: string;
  full_name?: string | null;
};


export type UserUpdate = {
  email?: string | null;
  is_active?: boolean;
  is_superuser?: boolean;
  full_name?: string | null;
  password?: string | null;
};


export type UserUploadResume = {
  resume: File;
};

export type UserUpdateMe = {
  username?: string | null;
  name?: string | null;
  parsed_personal?: Record<string, any>;
  parsed_work_experiences?: Record<string, any>;
  parsed_educations?: Record<string, any>;
  parsed_languages?: Record<string, any>;
  parsed_skills?: string[];
  additional_info?: string;
};


export type ValidationError = {
  loc: Array<string | number>;
  msg: string;
  type: string;
};

export type ModelNames = {
  llm_alias: string;
  llm_value: string;
}


export type ModelParameters = {
  name: string;
  temperature: number;
}

export type GetJobPostingParameters = {
  skip?: number;
  limit?: number;
  job_title?: string;
  company_name?: string;
};

export type JobPosting = {
  id: number;
  title: string;
  company: string;
  location: string | null;
  description: string;
  seniority_level: string | null;
  employment_type: string | null;
  experience_level: string | null;
  remote_modality: string | null;
  salary_range: string | null;
  industries: string[] | null;
  job_functions: string[] | null;
  skills: string[] | null;
  job_salary_min: number | null;
  job_salary_max: number | null;
  job_poster_name: string | null;
  job_poster_profile: string | null;
  summary: Record<string, any> | null;
  institution_about: string | null;
  institution_website: string | null;
  institution_industry: string | null;
  institution_size: string | null;
  institution_followers: number | null;
  institution_employees: number | null;
  institution_tagline: string | null;
  institution_location: string | null;
  institution_specialties: string[] | null;
};

export type JobPostings = {
  data: JobPosting[];
};

export type WorkExperience = {
  id: number;
  comparison_id: number;
  start_date: string;
  end_date: string;
  title: string;
  company: string;
  accomplishments: string[];
};

export type CoverLetterParagraph = {
  id: number;
  comparison_id: number;
  paragraph_number: number;
  paragraph_text: string;
};


export type UserJobPostingComparison = {
  id: number;
  user_id: number;
  job_posting_id: number;
  title: string;
  location: string | null;
  company: string;
  comparison: Record<string, any> | null;
  resume: string | null;
  cover_letter: string | null;
  is_active: boolean;
  work_experiences: WorkExperience[];
  cover_letter_paragraphs: CoverLetterParagraph[];
};
export interface UserJobPostingComparisons {
  data: UserJobPostingComparison[];
}



===== ./client/services.ts =====
import type { CancelablePromise } from './core/CancelablePromise';
import { OpenAPI } from './core/OpenAPI';
import { request as __request } from './core/request';

import type {
  Body_login_login_access_token, Message, NewPassword, Token, UserPublicMe, UpdatePassword, UserCreate, UserRegister, UserUpdateMe,
  ModelParameters, JobPostings, GetJobPostingParameters, UserJobPostingComparison, UserJobPostingComparisons, ModelNames, CoverLetterParagraph,
  WorkExperience
} from './models';

export type TDataLoginAccessToken = {
  formData: Body_login_login_access_token

}
export type TDataRecoverPassword = {
  email: string

}
export type TDataResetPassword = {
  requestBody: NewPassword

}
export type TDataRecoverPasswordHtmlContent = {
  email: string

}

export class LoginService {

  /**
   * Login Access Token
   * OAuth2 compatible token login, get an access token for future requests
   * @returns Token Successful Response
   * @throws ApiError
   */
  public static loginAccessToken(data: TDataLoginAccessToken): CancelablePromise<Token> {
    const {
      formData,
    } = data;
    return __request(OpenAPI, {
      method: 'POST',
      url: '/api/v1/login/access-token',
      formData: formData,
      mediaType: 'application/x-www-form-urlencoded',
      errors: {
        422: `Validation Error`,
      },
    });
  }

  /**
   * Test Token
   * Test access token
   * @returns UserPublic Successful Response
   * @throws ApiError
   */
  public static testToken(): CancelablePromise<UserPublicMe> {
    return __request(OpenAPI, {
      method: 'POST',
      url: '/api/v1/login/test-token',
    });
  }

  /**
   * Recover Password
   * Password Recovery
   * @returns Message Successful Response
   * @throws ApiError
   */
  public static recoverPassword(data: TDataRecoverPassword): CancelablePromise<Message> {
    const {
      email,
    } = data;
    return __request(OpenAPI, {
      method: 'POST',
      url: '/api/v1/password-recovery/{email}',
      path: {
        email
      },
      errors: {
        422: `Validation Error`,
      },
    });
  }

  /**
   * Reset Password
   * Reset password
   * @returns Message Successful Response
   * @throws ApiError
   */
  public static resetPassword(data: TDataResetPassword): CancelablePromise<Message> {
    const {
      requestBody,
    } = data;
    return __request(OpenAPI, {
      method: 'POST',
      url: '/api/v1/reset-password/',
      body: requestBody,
      mediaType: 'application/json',
      errors: {
        422: `Validation Error`,
      },
    });
  }

  /**
   * Recover Password Html Content
   * HTML Content for Password Recovery
   * @returns string Successful Response
   * @throws ApiError
   */
  public static recoverPasswordHtmlContent(data: TDataRecoverPasswordHtmlContent): CancelablePromise<string> {
    const {
      email,
    } = data;
    return __request(OpenAPI, {
      method: 'POST',
      url: '/api/v1/password-recovery-html-content/{email}',
      path: {
        email
      },
      errors: {
        422: `Validation Error`,
      },
    });
  }

}

export type TDataReadUsers = {
  limit?: number
  skip?: number

}
export type TDataCreateUser = {
  requestBody: UserCreate

}
export type TDataUpdateUserMe = {
  requestBody: UserUpdateMe

}
export type TDataUpdatePasswordMe = {
  requestBody: UpdatePassword

}
export type TDataUserUploadCV = {
  requestBody: FormData
}
export type TDataRegisterUser = {
  requestBody: UserRegister

}
export type TDataReadUserById = {
  userId: number

}
export type TDataDeleteUser = {
  userId: number

}

export type TDataparseResume = {
  requestBody: ModelParameters
}

export type TDataUserUploadResume = {
  formData: FormData;
};

export class UsersService {
  /**
   * Create User
   * Create new user.
   * @returns UserPublic Successful Response
   * @throws ApiError
   */
  public static createUser(data: TDataCreateUser): CancelablePromise<UserPublicMe> {
    const {
      requestBody,
    } = data;
    return __request(OpenAPI, {
      method: 'POST',
      url: '/api/v1/users/',
      body: requestBody,
      mediaType: 'application/json',
      errors: {
        422: `Validation Error`,
      },
    });
  }

  /**
   * Read User Me
   * Get current user.
   * @returns UserPublic Successful Response
   * @throws ApiError
   */
  public static readUserMe(): CancelablePromise<UserPublicMe> {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/api/v1/users/me',
    });
  }

  /**
   * Update User Me
   * Update own user.
   * @returns UserPublic Successful Response
   * @throws ApiError
   */
  public static updateUserMe(data: TDataUpdateUserMe): CancelablePromise<UserPublicMe> {
    const {
      requestBody,
    } = data;
    return __request(OpenAPI, {
      method: 'PATCH',
      url: '/api/v1/users/me',
      body: requestBody,
      mediaType: 'application/json',
      errors: {
        422: `Validation Error`,
      },
    });
  }

  /**
   * Update Password Me
   * Update own password.
   * @returns Message Successful Response
   * @throws ApiError
   */
  public static updatePasswordMe(data: TDataUpdatePasswordMe): CancelablePromise<Message> {
    const {
      requestBody,
    } = data;
    return __request(OpenAPI, {
      method: 'PATCH',
      url: '/api/v1/users/me/password',
      body: requestBody,
      mediaType: 'application/json',
      errors: {
        422: `Validation Error`,
      },
    });
  }

  /**
   * Register User
   * Create new user without the need to be logged in.
   * @returns UserPublic Successful Response
   * @throws ApiError
   */
  public static registerUser(data: TDataRegisterUser): CancelablePromise<UserPublicMe> {
    const {
      requestBody,
    } = data;
    return __request(OpenAPI, {
      method: 'POST',
      url: '/api/v1/users/signup',
      body: requestBody,
      mediaType: 'application/json',
      errors: {
        422: `Validation Error`,
      },
    });
  }

  /**
   * Read User By Id
   * Get a specific user by id.
   * @returns UserPublic Successful Response
   * @throws ApiError
   */
  public static readUserById(data: TDataReadUserById): CancelablePromise<UserPublicMe> {
    const {
      userId,
    } = data;
    return __request(OpenAPI, {
      method: 'GET',
      url: '/api/v1/users/{user_id}',
      path: {
        user_id: userId
      },
      errors: {
        422: `Validation Error`,
      },
    });
  }

  /**
  * Upload CV of the current user
  * @returns Message Successful Response
  * @throws ApiError
  */
  public static uploadResume(data: TDataUserUploadResume): CancelablePromise<Message> {
    const { formData } = data;
    return __request(OpenAPI, {
      method: 'POST',
      url: '/api/v1/users/me/upload-resume',
      body: formData,
      mediaType: 'multipart/form-data',
      errors: {
        422: `Validation Error`,
      },

    },);
  }
  /** 
   * Parse CV of the current user
  * @returns Message Successful Response
  * @throws ApiError
  */
  public static parseResume(data: TDataparseResume): CancelablePromise<Message> {
    const { requestBody } = data;
    return __request(OpenAPI, {
      body: requestBody,
      method: 'PATCH',
      url: '/api/v1/users/me/parse-resume',
    });
  }


  /**
   * Delete User
   * Delete a user.
   * @returns Message Successful Response
   * @throws ApiError
   */
  public static deleteUser(data: TDataDeleteUser): CancelablePromise<Message> {
    const {
      userId,
    } = data;
    return __request(OpenAPI, {
      method: 'DELETE',
      url: '/api/v1/users/{user_id}',
      path: {
        user_id: userId
      },
      errors: {
        422: `Validation Error`,
      },
    });
  }


}

export type TDataTestEmail = {
  emailTo: string

}

export class UtilsService {

  /**
   * Test Email
   * Test emails.
   * @returns Message Successful Response
   * @throws ApiError
   */
  public static testEmail(data: TDataTestEmail): CancelablePromise<Message> {
    const {
      emailTo,
    } = data;
    return __request(OpenAPI, {
      method: 'POST',
      url: '/api/v1/utils/test-email/',
      query: {
        email_to: emailTo
      },
      errors: {
        422: `Validation Error`,
      },
    });
  }

}

export type TDataGetJobPostings = {
  requestBody: GetJobPostingParameters
}

export class JobPostingServices {

  /**
   * Get job posting items.
   * @returns JobPostings Successful Response
   * @throws ApiError
   */
  public static getJobPostings(data: TDataGetJobPostings): CancelablePromise<JobPostings> {
    const { requestBody } = data;
    const queryParams = new URLSearchParams(requestBody as any).toString();
    return __request(OpenAPI, {
      method: 'GET',
      url: `/api/v1/job-postings?${queryParams}`,
      errors: {
        422: `Validation Error`,
      },
    });
  }
}


export class UserComparisonServices {
  /**
   * Get comparison status for a job posting.
   * @param job_posting_id - The ID of the job posting.
   * @param comparison_id - The ID of the comparison.
   * @returns Message - The comparison status message.
   * @throws ApiError
   */
  public static getUserComparison(data: { comparison_id: number | null, job_posting_id: number | null }): CancelablePromise<UserJobPostingComparison> {
    const queryParams = new URLSearchParams();

    if (data.comparison_id !== null) {
      queryParams.append("comparison_id", data.comparison_id.toString());
    }

    if (data.job_posting_id !== null) {
      queryParams.append("job_posting_id", data.job_posting_id.toString());
    }
    return __request(OpenAPI, {
      method: 'GET',
      url: `/api/v1/comparisons/?${queryParams}`,
      errors: {
        404: `Comparison not found`,
      },
    });
  }

  public static getUserComparisons(): CancelablePromise<UserJobPostingComparisons> {
    return __request(OpenAPI, {
      method: 'GET',
      url: `/api/v1/comparisons/current_user`,
      errors: {
        404: `Current user comparisos not found`,
      },
    });
  }

  public static generateComparisonResume(data: { comparison_id: number }, parameters: ModelParameters): CancelablePromise<Message> {
    return __request(OpenAPI, {
      method: 'POST',
      url: `/api/v1/comparisons/generate-resume?comparison_id=${data.comparison_id}`,
      body: parameters,
      errors: {
        500: `Server Error`,
      },
    });
  }

  public static generateComparisonCoverLetter(data: { comparison_id: number }, parameters: ModelParameters): CancelablePromise<Message> {
    return __request(OpenAPI, {
      method: 'POST',
      url: `/api/v1/comparisons/generate-cover-letter?comparison_id=${data.comparison_id}`,
      body: parameters,
      errors: {
        500: `Server Error`,
      },
    });
  }


  /**
  * Activate comparison for a job posting.
  * @param job_posting_id - The ID of the job posting.
  * @returns Message - The activation status message.
  * @throws ApiError
  */
  public static activateUserComparison(data: { job_posting_id: number }): CancelablePromise<Message> {
    return __request(OpenAPI, {
      method: 'PATCH',
      url: `/api/v1/comparisons/create-activate?job_posting_id=${data.job_posting_id}`,
      errors: {
        500: `Server Error`,
      },
    });
  }
  public static editWorkExperience(data: { newWorkExperience: WorkExperience }): CancelablePromise<Message> {
    return __request(OpenAPI, {
      method: 'POST',
      url: '/api/v1/comparisons/edit-work-experience',
      body: data.newWorkExperience,
      errors: {
        404: `User or Work Experience not found`,
        500: `Server Error`,
      },
    });
  }

  public static editCoverLetterParagraph(data: { newCoverLetterParagraph: CoverLetterParagraph }): CancelablePromise<Message> {
    return __request(OpenAPI, {
      method: 'POST',
      url: '/api/v1/comparisons/edit-cover-letter-paragraph',
      body: data.newCoverLetterParagraph,
      errors: {
        404: `User or Cover Letter Paragraph not found`,
        500: `Server Error`,
      },
    });
  }
}




export class ModelNamesService {
  public static getModelNames(): CancelablePromise<ModelNames[]> {
    return __request(OpenAPI, {
      method: 'GET',
      url: '/api/v1/model-names'
    })
  }
}


===== ./main.tsx =====
import { ChakraProvider } from "@chakra-ui/react"
import { QueryClient, QueryClientProvider } from "@tanstack/react-query"
import { RouterProvider, createRouter } from "@tanstack/react-router"
import ReactDOM from "react-dom/client"
import { routeTree } from "./routeTree.gen"

import { StrictMode } from "react"
import { OpenAPI } from "./client"
import theme from "./theme"

OpenAPI.BASE = import.meta.env.VITE_API_URL
OpenAPI.TOKEN = async () => {
  return localStorage.getItem("access_token") || ""
}

const queryClient = new QueryClient()

const router = createRouter({ routeTree })
declare module "@tanstack/react-router" {
  interface Register {
    router: typeof router
  }
}

ReactDOM.createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <ChakraProvider theme={theme}>
      <QueryClientProvider client={queryClient}>
        <RouterProvider router={router} />
      </QueryClientProvider>
    </ChakraProvider>
  </StrictMode>,
)

===== ./theme.tsx =====
import { extendTheme } from "@chakra-ui/react"

const disabledStyles = {
  _disabled: {
    backgroundColor: "ui.main",
  },
}

const theme = extendTheme({
  colors: {
    ui: {
      main: "#009688",
      secondary: "#EDF2F7",
      success: "#48BB78",
      danger: "#E53E3E",
      light: "#FAFAFA",
      dark: "#1A202C",
      darkSlate: "#252D3D",
      dim: "#A0AEC0",
    },
  },
  components: {
    Button: {
      variants: {
        primary: {
          backgroundColor: "ui.main",
          color: "ui.light",
          _hover: {
            backgroundColor: "#00766C",
          },
          _disabled: {
            ...disabledStyles,
            _hover: {
              ...disabledStyles,
            },
          },
        },
        danger: {
          backgroundColor: "ui.danger",
          color: "ui.light",
          _hover: {
            backgroundColor: "#E32727",
          },
        },
      },
    },
    Tabs: {
      variants: {
        enclosed: {
          tab: {
            _selected: {
              color: "ui.main",
            },
          },
        },
      },
    },
  },
})

export default theme

===== ./components/JobPostings/Pagination.tsx =====

import React from 'react';
import { Button, HStack, Text } from "@chakra-ui/react";

interface PaginationProps {
  currentPage: number;
  onPageChange: (pageNumber: number) => void;
  totalItems: number;
  itemsPerPage: number;
}

const Pagination: React.FC<PaginationProps> = ({
  currentPage,
  onPageChange,
  totalItems,
  itemsPerPage,
}) => {
  const totalPages = Math.ceil(totalItems / itemsPerPage);

  const handlePrevious = () => {
    if (currentPage > 1) {
      onPageChange(currentPage - 1);
    }
  };

  const handleNext = () => {
    if (currentPage < totalPages) {
      onPageChange(currentPage + 1);
    }
  };

  return (
    <HStack spacing={4} justifyContent="center" my={4}>
      <Button onClick={handlePrevious} disabled={currentPage === 1}>
        Previous
      </Button>
      <Text>Page {currentPage} of {totalPages}</Text>
      <Button onClick={handleNext} disabled={currentPage === totalPages}>
        Next
      </Button>
    </HStack>
  );
};

export default Pagination;

===== ./components/JobPostings/JobList.tsx =====
import React from "react";
import { List, ListItem, Text } from "@chakra-ui/react";
import { JobPostings, JobPosting } from "../../client/models"

interface JobListProps {
  jobPostings: JobPostings;
  onJobSelect: (job: JobPosting) => void;
}
const JobList: React.FC<JobListProps> = ({ jobPostings, onJobSelect }) => {
  return (
    <List spacing={3}>
      {jobPostings.data.map((job: JobPosting) => (
        <ListItem key={job.id} onClick={() => onJobSelect(job)} cursor="pointer" p={2} _hover={{ bg: "gray.100" }}>
          <Text fontWeight="bold"> {job.title}</Text>
          <Text>{job.company}</Text>
          <Text>{job.location ?? "Unknown Location"}</Text>
        </ListItem>
      ))}
    </List>
  );
};

export default JobList;

===== ./components/JobPostings/JobDetails.tsx =====

import React from 'react';
import { Box, Text, Heading } from '@chakra-ui/react';
import { JobPosting } from '../../client/models';

interface JobDetailsProps {
  job: JobPosting;
}

const JobDetails: React.FC<JobDetailsProps> = ({ job }) => {

  const formatDescription = (description: string) => {
    return description.split('\n').map((line, index) => (
      <React.Fragment key={index}>
        {line}
        <br />
      </React.Fragment>
    ));
  };


  return (
    <Box>
      <Heading size="lg">{job.title}</Heading>
      <Text fontWeight="bold">{job.company}</Text>
      <Text>{job.location ?? 'Location not specified'}</Text>
      <Text mt={4}>{formatDescription(job.description)}</Text>
      <Box mt={4}>
        <Text fontWeight="bold">Seniority Level:</Text>
        <Text>{job.seniority_level ?? 'Not specified'}</Text>
      </Box>
      <Box mt={4}>
        <Text fontWeight="bold">Employment Type:</Text>
        <Text>{job.employment_type ?? 'Not specified'}</Text>
      </Box>
      <Box mt={4}>
        <Text fontWeight="bold">Experience Level:</Text>
        <Text>{job.experience_level ?? 'Not specified'}</Text>
      </Box>
      <Box mt={4}>
        <Text fontWeight="bold">Remote Modality:</Text>
        <Text>{job.remote_modality ?? 'Not specified'}</Text>
      </Box>
      <Box mt={4}>
        <Text fontWeight="bold">Salary Range:</Text>
        <Text>{job.salary_range ?? 'Not specified'}</Text>
      </Box>
      <Box mt={4}>
        <Text fontWeight="bold">About the Company:</Text>
        <Text>{job.institution_about ?? 'Not specified'}</Text>
      </Box>
      <Box mt={4}>
        <Text fontWeight="bold">Website:</Text>
        <Text>{job.institution_website ?? 'Not specified'}</Text>
      </Box>
      <Box mt={4}>
        <Text fontWeight="bold">Industry:</Text>
        <Text>{job.institution_industry ?? 'Not specified'}</Text>
      </Box>
      <Box mt={4}>
        <Text fontWeight="bold">Company Size:</Text>
        <Text>{job.institution_size ?? 'Not specified'}</Text>
      </Box>
      <Box mt={4}>
        <Text fontWeight="bold">Followers:</Text>
        <Text>{job.institution_followers ?? 'Not specified'}</Text>
      </Box>
      <Box mt={4}>
        <Text fontWeight="bold">Employees:</Text>
        <Text>{job.institution_employees ?? 'Not specified'}</Text>
      </Box>
      <Box mt={4}>
        <Text fontWeight="bold">Tagline:</Text>
        <Text>{job.institution_tagline ?? 'Not specified'}</Text>
      </Box>
      <Box mt={4}>
        <Text fontWeight="bold">Location:</Text>
        <Text>{job.institution_location ?? 'Not specified'}</Text>
      </Box>
      <Box mt={4}>
        <Text fontWeight="bold">Specialties:</Text>
        <Text>{job.institution_specialties?.join(', ') ?? 'Not specified'}</Text>
      </Box>
    </Box>
  );
};

export default JobDetails;

===== ./components/comparisons/ComparisonList.tsx =====
import React from "react";
import { List, ListItem, Text } from "@chakra-ui/react";
import { UserJobPostingComparison, UserJobPostingComparisons } from "../../client/models";

interface ComparisonListProps {
  jobComparisons: UserJobPostingComparisons;
  onComparisonSelect: (comparison: UserJobPostingComparison) => void;
}

const ComparisonList: React.FC<ComparisonListProps> = ({ jobComparisons, onComparisonSelect }) => {
  return (
    <List spacing={3}>
      {jobComparisons.data.map((comparison: UserJobPostingComparison) => (
        <ListItem
          key={comparison.id} // Ensure the key is unique for each item
          onClick={() => onComparisonSelect(comparison)}
          cursor="pointer"
          p={2}
          _hover={{ bg: "gray.100" }}
        >
          <Text fontWeight="bold">{comparison.title}</Text>
          <Text>{comparison.company}</Text>
          <Text>{comparison.location ?? "Unknown Location"}</Text>
        </ListItem>
      ))}
    </List>
  );
};

export default ComparisonList;

===== ./components/comparisons/ComparisonDetails.tsx =====
import React, { useState } from "react";
import {
  Box,
  Heading,
  Text,
  Tabs,
  TabList,
  TabPanels,
  Tab,
  TabPanel,
  Button,
  useToast,
} from "@chakra-ui/react";
import { UserJobPostingComparison } from "../../client/models";
import { PdfDisplay } from "../Common/PdfDisplay";
import WorkExperienceDisplay from "./WorkExperienceDisplay";
import CoverLetterParagraphDisplay from "./CoverLetterParagraphDisplay";
import ModelTemperatureSelector from "../Common/ModelTemperatureSelector";
import { UserComparisonServices } from "../../client/services";

interface ComparisonDetailsProps {
  comparison: UserJobPostingComparison;
  onComparisonUpdate: (updatedComparison: UserJobPostingComparison) => void;
}

const ComparisonDetails: React.FC<ComparisonDetailsProps> = ({
  comparison,
  onComparisonUpdate,
}) => {
  const [model, setModel] = useState<string>("");
  const [temperature, setTemperature] = useState<number>(0.5);
  const [isGeneratingResume, setIsGeneratingResume] = useState(false);
  const [isGeneratingCoverLetter, setIsGeneratingCoverLetter] = useState(false);
  const toast = useToast();

  const handleGenerateResume = () => {
    setIsGeneratingResume(true);
    UserComparisonServices.generateComparisonResume(
      { comparison_id: comparison.id },
      {
        name: model,
        temperature: temperature,
      }
    )
      .then((response) => {
        toast({
          title: "Resume Generated",
          description: response.message,
          status: "success",
          duration: 3000,
          isClosable: true,
        });
        refreshComparisonData();
      })
      .catch((error) => {
        console.error("Error generating resume:", error);
        toast({
          title: "Error",
          description: "Failed to generate resume",
          status: "error",
          duration: 3000,
          isClosable: true,
        });
      })
      .finally(() => {
        setIsGeneratingResume(false);
      });
  };

  const handleGenerateCoverLetter = () => {
    setIsGeneratingCoverLetter(true);
    UserComparisonServices.generateComparisonCoverLetter(
      { comparison_id: comparison.id },
      {
        name: model,
        temperature: temperature,
      }
    )
      .then((response) => {
        toast({
          title: "Cover Letter Generated",
          description: response.message,
          status: "success",
          duration: 3000,
          isClosable: true,
        });
        refreshComparisonData();
      })
      .catch((error) => {
        console.error("Error generating cover letter:", error);
        toast({
          title: "Error",
          description: "Failed to generate cover letter",
          status: "error",
          duration: 3000,
          isClosable: true,
        });
      })
      .finally(() => {
        setIsGeneratingCoverLetter(false);
      });
  };

  const refreshComparisonData = () => {
    UserComparisonServices.getUserComparison({
      comparison_id: comparison.id,
      job_posting_id: null,
    })
      .then((updatedComparison) => {
        onComparisonUpdate(updatedComparison as UserJobPostingComparison);
      })
      .catch((error) => {
        console.error("Error refreshing comparison data:", error);
        toast({
          title: "Error",
          description: "Failed to refresh comparison data",
          status: "error",
          duration: 3000,
          isClosable: true,
        });
      });
  };

  return (
    <Box p={4}>
      <Heading as="h1" size="xl" mb={4}>
        {comparison.title}
      </Heading>
      <Text fontSize="lg" mb={2}>
        {comparison.company}
      </Text>
      <Text fontSize="md" color="gray.600" mb={4}>
        {comparison.location ?? "Unknown Location"}
      </Text>

      <ModelTemperatureSelector
        model={model}
        setModel={setModel}
        temperature={temperature}
        setTemperature={setTemperature}
      />

      <Tabs>
        <TabList>
          <Tab>Resume</Tab>
          <Tab>Cover Letter</Tab>
        </TabList>

        <TabPanels>
          <TabPanel>
            <Box mb={4}>
              {comparison.resume ? (
                <>
                  <Button
                    onClick={handleGenerateResume}
                    mb={4}
                    isLoading={isGeneratingResume}
                    loadingText="Regenerating..."
                  >
                    Regenerate Resume
                  </Button>
                  <PdfDisplay
                    base64String={comparison.resume}
                    fileName={`${comparison.title}_${comparison.company}_Resume.pdf`}
                  />
                </>
              ) : (
                <>
                  <Text>No resume available</Text>
                  <Button
                    onClick={handleGenerateResume}
                    mb={4}
                    isLoading={isGeneratingResume}
                    loadingText="Generating..."
                  >
                    Generate Resume
                  </Button>
                </>
              )}
            </Box>
            <Box>
              <Heading as="h3" size="sm" mb={2}>
                Work Experiences
              </Heading>
              <WorkExperienceDisplay
                experiences={comparison.work_experiences}
                onUpdate={refreshComparisonData}
              />
            </Box>
          </TabPanel>
          <TabPanel>
            <Box mb={4}>
              {comparison.cover_letter ? (
                <>
                  <Button
                    onClick={handleGenerateCoverLetter}
                    mb={4}
                    isLoading={isGeneratingCoverLetter}
                    loadingText="Regenerating..."
                  >
                    Regenerate Cover Letter
                  </Button>
                  <PdfDisplay
                    base64String={comparison.cover_letter}
                    fileName={`${comparison.title.replace(/\s+/g, '')}_${comparison.company.replace(/\s+/g, '')}_cover_letter.pdf`}
                  />
                </>
              ) : (
                <>
                  <Text>No cover letter available</Text>
                  <Button
                    onClick={handleGenerateCoverLetter}
                    mb={4}
                    isLoading={isGeneratingCoverLetter}
                    loadingText="Generating..."
                  >
                    Generate Cover Letter
                  </Button>
                </>
              )}
            </Box>
            <Box>
              <Heading as="h3" size="sm" mb={2}>
                Cover Letter Paragraphs
              </Heading>
              <CoverLetterParagraphDisplay
                paragraphs={comparison.cover_letter_paragraphs}
                onUpdate={refreshComparisonData}
              />
            </Box>
          </TabPanel>
        </TabPanels>
      </Tabs>
    </Box>
  );
};

export default ComparisonDetails;

===== ./components/comparisons/WorkExperienceDisplay.tsx =====
import React, { useState, useEffect } from "react";
import {
  Box,
  Text,
  IconButton,
  Flex,
  Input,
  Button,
  useToast,
  VStack,
  HStack,
} from "@chakra-ui/react";
import { EditIcon, CheckIcon, CloseIcon, AddIcon, DeleteIcon } from "@chakra-ui/icons";
import { WorkExperience } from "../../client/models";
import { UserComparisonServices } from "../../client/services";

interface WorkExperiencesProps {
  experiences: WorkExperience[] | undefined;
  onUpdate: () => void;
}

const WorkExperienceDisplay: React.FC<WorkExperiencesProps> = ({ experiences, onUpdate }) => {
  const [editingIndex, setEditingIndex] = useState<number | null>(null);
  const [editedExperiences, setEditedExperiences] = useState<WorkExperience[]>([]);
  const [newAccomplishment, setNewAccomplishment] = useState("");
  const toast = useToast();

  useEffect(() => {
    if (experiences) {
      setEditedExperiences(experiences);
    }
  }, [experiences]);

  const handleEdit = (index: number) => {
    setEditingIndex(index);
  };

  const handleSave = async (index: number) => {
    try {
      await UserComparisonServices.editWorkExperience({
        newWorkExperience: editedExperiences[index]
      });
      toast({
        title: "Work Experience updated",
        description: `Experience ${index + 1} has been successfully updated.`,
        status: "success",
        duration: 3000,
        isClosable: true,
      });
      setEditingIndex(null);
      onUpdate();
    } catch (error) {
      console.error("Error updating work experience:", error);
      toast({
        title: "Error",
        description: "Failed to update work experience",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
    }
  };

  const handleCancel = (index: number) => {
    if (experiences) {
      setEditedExperiences(prevExperiences => {
        const newExperiences = [...prevExperiences];
        newExperiences[index] = experiences[index];
        return newExperiences;
      });
    }
    setEditingIndex(null);
  };

  const handleChange = (index: number, field: keyof WorkExperience, value: string) => {
    setEditedExperiences(prevExperiences => {
      const newExperiences = [...prevExperiences];
      newExperiences[index] = { ...newExperiences[index], [field]: value };
      return newExperiences;
    });
  };

  const handleAddAccomplishment = (index: number) => {
    if (newAccomplishment.trim()) {
      setEditedExperiences(prevExperiences => {
        const newExperiences = [...prevExperiences];
        newExperiences[index] = {
          ...newExperiences[index],
          accomplishments: [...newExperiences[index].accomplishments, newAccomplishment.trim()]
        };
        return newExperiences;
      });
      setNewAccomplishment("");
    }
  };

  const handleEditAccomplishment = (experienceIndex: number, accomplishmentIndex: number, value: string) => {
    setEditedExperiences(prevExperiences => {
      const newExperiences = [...prevExperiences];
      const newAccomplishments = [...newExperiences[experienceIndex].accomplishments];
      newAccomplishments[accomplishmentIndex] = value;
      newExperiences[experienceIndex] = { ...newExperiences[experienceIndex], accomplishments: newAccomplishments };
      return newExperiences;
    });
  };

  const handleRemoveAccomplishment = (experienceIndex: number, accomplishmentIndex: number) => {
    setEditedExperiences(prevExperiences => {
      const newExperiences = [...prevExperiences];
      const newAccomplishments = newExperiences[experienceIndex].accomplishments.filter((_, index) => index !== accomplishmentIndex);
      newExperiences[experienceIndex] = { ...newExperiences[experienceIndex], accomplishments: newAccomplishments };
      return newExperiences;
    });
  };

  if (!experiences || experiences.length === 0) {
    return <Box>No work experiences available.</Box>;
  }

  return (
    <VStack align="stretch" spacing={4}>
      {editedExperiences.map((experience, index) => (
        <Box key={experience.id} p={4} border="1px solid #ccc" borderRadius="md" position="relative">
          {editingIndex === index ? (
            <VStack spacing={3} align="stretch">
              <Input
                value={experience.title}
                onChange={(e) => handleChange(index, 'title', e.target.value)}
                placeholder="Title"
              />
              <Input
                value={experience.company}
                onChange={(e) => handleChange(index, 'company', e.target.value)}
                placeholder="Company"
              />
              <Input
                value={experience.start_date}
                onChange={(e) => handleChange(index, 'start_date', e.target.value)}
                placeholder="Start Date"
              />
              <Input
                value={experience.end_date}
                onChange={(e) => handleChange(index, 'end_date', e.target.value)}
                placeholder="End Date"
              />
              <Text fontWeight="bold">Accomplishments:</Text>
              {experience.accomplishments.map((accomplishment, accIndex) => (
                <HStack key={accIndex}>
                  <Input
                    value={accomplishment}
                    onChange={(e) => handleEditAccomplishment(index, accIndex, e.target.value)}
                  />
                  <IconButton
                    aria-label="Remove accomplishment"
                    icon={<DeleteIcon />}
                    onClick={() => handleRemoveAccomplishment(index, accIndex)}
                  />
                </HStack>
              ))}
              <HStack>
                <Input
                  value={newAccomplishment}
                  onChange={(e) => setNewAccomplishment(e.target.value)}
                  placeholder="New accomplishment"
                />
                <Button onClick={() => handleAddAccomplishment(index)} leftIcon={<AddIcon />}>
                  Add
                </Button>
              </HStack>
              <Flex justify="flex-end" mt={4}>
                <Button onClick={() => handleSave(index)} colorScheme="green" mr={2}>
                  <CheckIcon mr={2} /> Save
                </Button>
                <Button onClick={() => handleCancel(index)} colorScheme="red">
                  <CloseIcon mr={2} /> Cancel
                </Button>
              </Flex>
            </VStack>
          ) : (
            <>
              <IconButton
                aria-label="Edit"
                icon={<EditIcon />}
                size="sm"
                onClick={() => handleEdit(index)}
                position="absolute"
                top={2}
                right={2}
              />
              <VStack align="stretch" spacing={2}>
                <Text fontWeight="bold">{experience.title}</Text>
                <Text>{experience.company}</Text>
                <Text>{`${experience.start_date} - ${experience.end_date}`}</Text>
                <Text fontWeight="bold" mt={2}>Accomplishments:</Text>
                <VStack align="stretch" pl={4}>
                  {experience.accomplishments.map((accomplishment, accIndex) => (
                    <Text key={accIndex}>• {accomplishment}</Text>
                  ))}
                </VStack>
              </VStack>
            </>
          )}
        </Box>
      ))}
    </VStack>
  );
};

export default WorkExperienceDisplay;

===== ./components/comparisons/CoverLetterParagraphDisplay.tsx =====
import React, { useState, useEffect } from "react";
import {
  Box,
  Text,
  IconButton,
  Flex,
  Textarea,
  Button,
  useToast,
  VStack,
} from "@chakra-ui/react";
import { EditIcon, CheckIcon, CloseIcon } from "@chakra-ui/icons";
import { CoverLetterParagraphPublic } from "../../client/models";
import { UserComparisonServices } from "../../client/services";

interface CoverLetterParagraphsProps {
  paragraphs: CoverLetterParagraphPublic[] | undefined;
  onUpdate: () => void;
}

const CoverLetterParagraph: React.FC<CoverLetterParagraphsProps> = ({ paragraphs, onUpdate }) => {
  const [editingIndex, setEditingIndex] = useState<number | null>(null);
  const [editedParagraphs, setEditedParagraphs] = useState<CoverLetterParagraphPublic[]>([]);
  const toast = useToast();

  useEffect(() => {
    if (paragraphs) {
      setEditedParagraphs(paragraphs);
    }
  }, [paragraphs]);

  const handleEdit = (index: number) => {
    setEditingIndex(index);
  };

  const handleSave = async (index: number) => {
    try {
      await UserComparisonServices.editCoverLetterParagraph({
        newCoverLetterParagraph: editedParagraphs[index]
      });
      toast({
        title: "Cover Letter Paragraph updated",
        description: `Paragraph ${index + 1} has been successfully updated.`,
        status: "success",
        duration: 3000,
        isClosable: true,
      });
      setEditingIndex(null);
      onUpdate();
    } catch (error) {
      console.error("Error updating cover letter paragraph:", error);
      toast({
        title: "Error",
        description: "Failed to update cover letter paragraph",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
    }
  };

  const handleCancel = (index: number) => {
    if (paragraphs) {
      setEditedParagraphs(prevParagraphs => {
        const newParagraphs = [...prevParagraphs];
        newParagraphs[index] = paragraphs[index];
        return newParagraphs;
      });
    }
    setEditingIndex(null);
  };

  const handleChange = (index: number, newText: string) => {
    setEditedParagraphs(prevParagraphs => {
      const newParagraphs = [...prevParagraphs];
      newParagraphs[index] = { ...newParagraphs[index], paragraph_text: newText };
      return newParagraphs;
    });
  };

  if (!paragraphs || paragraphs.length === 0) {
    return <Box>No cover letter paragraphs available.</Box>;
  }

  return (
    <VStack align="stretch" spacing={4}>
      {editedParagraphs.map((paragraph, index) => (
        <Box key={paragraph.id} p={4} border="1px solid #ccc" borderRadius="md" position="relative">
          {editingIndex === index ? (
            <>
              <Textarea
                value={paragraph.paragraph_text}
                onChange={(e) => handleChange(index, e.target.value)}
                rows={4}
                mb={3}
              />
              <Flex justify="flex-end">
                <Button onClick={() => handleSave(index)} colorScheme="green" mr={2}>
                  <CheckIcon mr={2} /> Save
                </Button>
                <Button onClick={() => handleCancel(index)} colorScheme="red">
                  <CloseIcon mr={2} /> Cancel
                </Button>
              </Flex>
            </>
          ) : (
            <>
              <IconButton
                aria-label="Edit"
                icon={<EditIcon />}
                size="sm"
                onClick={() => handleEdit(index)}
                position="absolute"
                top={2}
                right={2}
              />
              <Text fontWeight="bold" mb={2}>Paragraph {paragraph.paragraph_number}</Text>
              <Text>{paragraph.paragraph_text}</Text>
            </>
          )}
        </Box>
      ))}
    </VStack>
  );
};

export default CoverLetterParagraph;

===== ./components/comparisons/Layout.tsx =====
import React, { useEffect, useState } from "react";
import { Container, Flex, Box, Text } from "@chakra-ui/react";
import ComparisonList from "./ComparisonList";
import { UserComparisonServices } from "../../client/services";
import { UserJobPostingComparison, UserJobPostingComparisons } from "../../client/models";
import ComparisonDetails from "./ComparisonDetails";

const MainLayout: React.FC = () => {
  const [jobComparisons, setJobComparisons] = useState<UserJobPostingComparisons | null>(null);
  const [selectedJobComparison, setSelectedJobComparison] = useState<UserJobPostingComparison | null>(null);

  useEffect(() => {
    const fetchComparisons = async () => {
      try {
        const response = await UserComparisonServices.getUserComparisons();
        setJobComparisons(response);
      } catch (error) {
        console.error("Error fetching job comparisons:", error);
      }
    };

    fetchComparisons();
  }, []);

  const handleJobComparisonSelect = (comparison: UserJobPostingComparison): void => {
    const fetchJobDetails = async () => {
      try {
        const response = await UserComparisonServices.getUserComparison({
          comparison_id: comparison.id,
          job_posting_id: null
        });
        setSelectedJobComparison(response as UserJobPostingComparison);
      } catch (error) {
        console.error("Error fetching job comparison:", error);
      }
    };
    fetchJobDetails();
  };

  const handleComparisonUpdate = (updatedComparison: UserJobPostingComparison) => {
    setSelectedJobComparison(updatedComparison);
    // Also update the comparison in the list if necessary
    if (jobComparisons) {
      const updatedComparisons = {
        ...jobComparisons,
        data: jobComparisons.data.map(comp =>
          comp.id === updatedComparison.id ? updatedComparison : comp
        )
      };
      setJobComparisons(updatedComparisons);
    }
  };

  return (
    <Container maxW="full">
      <Flex height="100vh">
        <Box width="20%" overflowY="scroll" borderRight="1px solid #ccc">
          {jobComparisons && (
            <ComparisonList jobComparisons={jobComparisons} onComparisonSelect={handleJobComparisonSelect} />
          )}
        </Box>
        <Box width="80%" p={2}>
          {selectedJobComparison ? (
            <ComparisonDetails
              comparison={selectedJobComparison}
              onComparisonUpdate={handleComparisonUpdate}
            />
          ) : (
            <Text>Select a job to see details</Text>
          )}
        </Box>
      </Flex>
    </Container>
  );
};

export default MainLayout;

===== ./components/Admin/EditUser.tsx =====
// import {
//   Button,
//   Checkbox,
//   Flex,
//   FormControl,
//   FormErrorMessage,
//   FormLabel,
//   Input,
//   Modal,
//   ModalBody,
//   ModalCloseButton,
//   ModalContent,
//   ModalFooter,
//   ModalHeader,
//   ModalOverlay,
// } from "@chakra-ui/react"
// import { useMutation, useQueryClient } from "@tanstack/react-query"
// import { type SubmitHandler, useForm } from "react-hook-form"
//
// import {
//   type ApiError,
//   type UserPublic,
//   type UserUpdate,
//   UsersService,
// } from "../../client"
// import useCustomToast from "../../hooks/useCustomToast"
// import { emailPattern } from "../../utils"
//
// interface EditUserProps {
//   user: UserPublic
//   isOpen: boolean
//   onClose: () => void
// }
//
// interface UserUpdateForm extends UserUpdate {
//   confirm_password: string
// }
//
// const EditUser = ({ user, isOpen, onClose }: EditUserProps) => {
//   const queryClient = useQueryClient()
//   const showToast = useCustomToast()
//
//   const {
//     register,
//     handleSubmit,
//     reset,
//     getValues,
//     formState: { errors, isSubmitting, isDirty },
//   } = useForm<UserUpdateForm>({
//     mode: "onBlur",
//     criteriaMode: "all",
//     defaultValues: user,
//   })
//
//   const mutation = useMutation({
//     mutationFn: (data: UserUpdateForm) =>
//       UsersService.updateUser({ userId: user.id, requestBody: data }),
//     onSuccess: () => {
//       showToast("Success!", "User updated successfully.", "success")
//       onClose()
//     },
//     onError: (err: ApiError) => {
//       const errDetail = (err.body as any)?.detail
//       showToast("Something went wrong.", `${errDetail}`, "error")
//     },
//     onSettled: () => {
//       queryClient.invalidateQueries({ queryKey: ["users"] })
//     },
//   })
//
//   const onSubmit: SubmitHandler<UserUpdateForm> = async (data) => {
//     if (data.password === "") {
//       data.password = undefined
//     }
//     mutation.mutate(data)
//   }
//
//   const onCancel = () => {
//     reset()
//     onClose()
//   }
//
//   return (
//     <>
//       <Modal
//         isOpen={isOpen}
//         onClose={onClose}
//         size={{ base: "sm", md: "md" }}
//         isCentered
//       >
//         <ModalOverlay />
//         <ModalContent as="form" onSubmit={handleSubmit(onSubmit)}>
//           <ModalHeader>Edit User</ModalHeader>
//           <ModalCloseButton />
//           <ModalBody pb={6}>
//             <FormControl isInvalid={!!errors.email}>
//               <FormLabel htmlFor="email">Email</FormLabel>
//               <Input
//                 id="email"
//                 {...register("email", {
//                   required: "Email is required",
//                   pattern: emailPattern,
//                 })}
//                 placeholder="Email"
//                 type="email"
//               />
//               {errors.email && (
//                 <FormErrorMessage>{errors.email.message}</FormErrorMessage>
//               )}
//             </FormControl>
//             <FormControl mt={4}>
//               <FormLabel htmlFor="name">Full name</FormLabel>
//               <Input id="name" {...register("full_name")} type="text" />
//             </FormControl>
//             <FormControl mt={4} isInvalid={!!errors.password}>
//               <FormLabel htmlFor="password">Set Password</FormLabel>
//               <Input
//                 id="password"
//                 {...register("password", {
//                   minLength: {
//                     value: 8,
//                     message: "Password must be at least 8 characters",
//                   },
//                 })}
//                 placeholder="Password"
//                 type="password"
//               />
//               {errors.password && (
//                 <FormErrorMessage>{errors.password.message}</FormErrorMessage>
//               )}
//             </FormControl>
//             <FormControl mt={4} isInvalid={!!errors.confirm_password}>
//               <FormLabel htmlFor="confirm_password">Confirm Password</FormLabel>
//               <Input
//                 id="confirm_password"
//                 {...register("confirm_password", {
//                   validate: (value) =>
//                     value === getValues().password ||
//                     "The passwords do not match",
//                 })}
//                 placeholder="Password"
//                 type="password"
//               />
//               {errors.confirm_password && (
//                 <FormErrorMessage>
//                   {errors.confirm_password.message}
//                 </FormErrorMessage>
//               )}
//             </FormControl>
//             <Flex>
//               <FormControl mt={4}>
//                 <Checkbox {...register("is_superuser")} colorScheme="teal">
//                   Is superuser?
//                 </Checkbox>
//               </FormControl>
//               <FormControl mt={4}>
//                 <Checkbox {...register("is_active")} colorScheme="teal">
//                   Is active?
//                 </Checkbox>
//               </FormControl>
//             </Flex>
//           </ModalBody>
//
//           <ModalFooter gap={3}>
//             <Button
//               variant="primary"
//               type="submit"
//               isLoading={isSubmitting}
//               isDisabled={!isDirty}
//             >
//               Save
//             </Button>
//             <Button onClick={onCancel}>Cancel</Button>
//           </ModalFooter>
//         </ModalContent>
//       </Modal>
//     </>
//   )
// }
//
// export default EditUser

===== ./components/Admin/AddUser.tsx =====
// import {
//   Button,
//   Checkbox,
//   Flex,
//   FormControl,
//   FormErrorMessage,
//   FormLabel,
//   Input,
//   Modal,
//   ModalBody,
//   ModalCloseButton,
//   ModalContent,
//   ModalFooter,
//   ModalHeader,
//   ModalOverlay,
// } from "@chakra-ui/react"
// import { useMutation, useQueryClient } from "@tanstack/react-query"
// import { type SubmitHandler, useForm } from "react-hook-form"
//
// import { type UserCreate, UsersService } from "../../client"
// import type { ApiError } from "../../client/core/ApiError"
// import useCustomToast from "../../hooks/useCustomToast"
// import { emailPattern } from "../../utils"
//
// interface AddUserProps {
//   isOpen: boolean
//   onClose: () => void
// }
//
// interface UserCreateForm extends UserCreate {
//   confirm_password: string
// }
//
// const AddUser = ({ isOpen, onClose }: AddUserProps) => {
//   const queryClient = useQueryClient()
//   const showToast = useCustomToast()
//   const {
//     register,
//     handleSubmit,
//     reset,
//     getValues,
//     formState: { errors, isSubmitting },
//   } = useForm<UserCreateForm>({
//     mode: "onBlur",
//     criteriaMode: "all",
//     defaultValues: {
//       email: "",
//       full_name: "",
//       password: "",
//       confirm_password: "",
//       is_superuser: false,
//       is_active: false,
//     },
//   })
//
//   const mutation = useMutation({
//     mutationFn: (data: UserCreate) =>
//       UsersService.createUser({ requestBody: data }),
//     onSuccess: () => {
//       showToast("Success!", "User created successfully.", "success")
//       reset()
//       onClose()
//     },
//     onError: (err: ApiError) => {
//       const errDetail = (err.body as any)?.detail
//       showToast("Something went wrong.", `${errDetail}`, "error")
//     },
//     onSettled: () => {
//       queryClient.invalidateQueries({ queryKey: ["users"] })
//     },
//   })
//
//   const onSubmit: SubmitHandler<UserCreateForm> = (data) => {
//     mutation.mutate(data)
//   }
//
//   return (
//     <>
//       <Modal
//         isOpen={isOpen}
//         onClose={onClose}
//         size={{ base: "sm", md: "md" }}
//         isCentered
//       >
//         <ModalOverlay />
//         <ModalContent as="form" onSubmit={handleSubmit(onSubmit)}>
//           <ModalHeader>Add User</ModalHeader>
//           <ModalCloseButton />
//           <ModalBody pb={6}>
//             <FormControl isRequired isInvalid={!!errors.email}>
//               <FormLabel htmlFor="email">Email</FormLabel>
//               <Input
//                 id="email"
//                 {...register("email", {
//                   required: "Email is required",
//                   pattern: emailPattern,
//                 })}
//                 placeholder="Email"
//                 type="email"
//               />
//               {errors.email && (
//                 <FormErrorMessage>{errors.email.message}</FormErrorMessage>
//               )}
//             </FormControl>
//             <FormControl mt={4} isInvalid={!!errors.full_name}>
//               <FormLabel htmlFor="name">Full name</FormLabel>
//               <Input
//                 id="name"
//                 {...register("full_name")}
//                 placeholder="Full name"
//                 type="text"
//               />
//               {errors.full_name && (
//                 <FormErrorMessage>{errors.full_name.message}</FormErrorMessage>
//               )}
//             </FormControl>
//             <FormControl mt={4} isRequired isInvalid={!!errors.password}>
//               <FormLabel htmlFor="password">Set Password</FormLabel>
//               <Input
//                 id="password"
//                 {...register("password", {
//                   required: "Password is required",
//                   minLength: {
//                     value: 8,
//                     message: "Password must be at least 8 characters",
//                   },
//                 })}
//                 placeholder="Password"
//                 type="password"
//               />
//               {errors.password && (
//                 <FormErrorMessage>{errors.password.message}</FormErrorMessage>
//               )}
//             </FormControl>
//             <FormControl
//               mt={4}
//               isRequired
//               isInvalid={!!errors.confirm_password}
//             >
//               <FormLabel htmlFor="confirm_password">Confirm Password</FormLabel>
//               <Input
//                 id="confirm_password"
//                 {...register("confirm_password", {
//                   required: "Please confirm your password",
//                   validate: (value) =>
//                     value === getValues().password ||
//                     "The passwords do not match",
//                 })}
//                 placeholder="Password"
//                 type="password"
//               />
//               {errors.confirm_password && (
//                 <FormErrorMessage>
//                   {errors.confirm_password.message}
//                 </FormErrorMessage>
//               )}
//             </FormControl>
//             <Flex mt={4}>
//               <FormControl>
//                 <Checkbox {...register("is_superuser")} colorScheme="teal">
//                   Is superuser?
//                 </Checkbox>
//               </FormControl>
//               <FormControl>
//                 <Checkbox {...register("is_active")} colorScheme="teal">
//                   Is active?
//                 </Checkbox>
//               </FormControl>
//             </Flex>
//           </ModalBody>
//           <ModalFooter gap={3}>
//             <Button variant="primary" type="submit" isLoading={isSubmitting}>
//               Save
//             </Button>
//             <Button onClick={onClose}>Cancel</Button>
//           </ModalFooter>
//         </ModalContent>
//       </Modal>
//     </>
//   )
// }
//
// export default AddUser

===== ./components/UserSettings/UserInformation.tsx =====
import {
  Box,
  Button,
  Container,
  Flex,
  FormControl,
  FormErrorMessage,
  FormLabel,
  Heading,
  Input,
  Text,
  Textarea,
  useColorModeValue,
} from "@chakra-ui/react"
import { useMutation, useQueryClient } from "@tanstack/react-query"
import { useState } from "react"
import { type SubmitHandler, useForm } from "react-hook-form"

import {
  type ApiError,
  type UserPublicMe,
  type UserUpdateMe,
  UsersService,
} from "../../client"
import useAuth from "../../hooks/useAuth"
import useCustomToast from "../../hooks/useCustomToast"
import { emailPattern } from "../../utils"

const UserInformation = () => {
  const queryClient = useQueryClient()
  const color = useColorModeValue("inherit", "ui.light")
  const showToast = useCustomToast()
  const [editMode, setEditMode] = useState(false)
  const { user: currentUser } = useAuth()
  const {
    register,
    handleSubmit,
    reset,
    getValues,
    formState: { isSubmitting, errors, isDirty },
  } = useForm<UserPublicMe>({
    mode: "onBlur",
    criteriaMode: "all",
    defaultValues: {
      name: currentUser?.name,
      username: currentUser?.username,
      additional_info: currentUser?.additional_info,
    },
  })

  const toggleEditMode = () => {
    setEditMode(!editMode)
  }

  const mutation = useMutation({
    mutationFn: (data: UserUpdateMe) =>
      UsersService.updateUserMe({ requestBody: data }),
    onSuccess: () => {
      showToast("Success!", "User updated successfully.", "success")
    },
    onError: (err: ApiError) => {
      const errDetail = (err.body as any)?.detail
      showToast("Something went wrong.", `${errDetail}`, "error")
    },
    onSettled: () => {
      // TODO: can we do just one call now?
      queryClient.invalidateQueries({ queryKey: ["users"] })
      queryClient.invalidateQueries({ queryKey: ["currentUser"] })
    },
  })

  const onSubmit: SubmitHandler<UserUpdateMe> = async (data) => {
    mutation.mutate(data)
  }

  const onCancel = () => {
    reset()
    toggleEditMode()
  }

  return (
    <>
      <Container maxW="full" as="form" onSubmit={handleSubmit(onSubmit)}>
        <Heading size="sm" py={4}>
          User Information
        </Heading>
        <Box w={{ sm: "full", md: "50%" }}>
          <FormControl>
            <FormLabel color={color} htmlFor="name">
              Full name
            </FormLabel>
            {editMode ? (
              <Input
                id="name"
                {...register("name", { maxLength: 30 })}
                type="text"
                size="md"
              />
            ) : (
              <Text
                size="md"
                py={2}
                color={!currentUser?.name ? "ui.dim" : "inherit"}
              >
                {currentUser?.name || "N/A"}
              </Text>
            )}
          </FormControl>
          <FormControl mt={4} isInvalid={!!errors.username}>
            <FormLabel color={color} htmlFor="email">
              Username
            </FormLabel>
            {editMode ? (
              <Input
                id="username"
                {...register("username", {
                  required: "Username is required",
                  pattern: emailPattern,
                })}
                type="username"
                size="md"
              />
            ) : (
              <Text size="md" py={2}>
                {currentUser?.username}
              </Text>
            )}
            {errors.username && (
              <FormErrorMessage>{errors.username.message}</FormErrorMessage>
            )}
          </FormControl>
          <FormControl>
            <FormLabel color={color} htmlFor="additional_info">
              Additional information
            </FormLabel>
            {editMode ? (
              <Textarea
                id="additional_info"
                {...register("additional_info", { maxLength: 1000 })}
                size="md"
              />
            ) : (
              <Text
                size="md"
                py={2}
                color={!currentUser?.additional_info ? "ui.dim" : "inherit"}
              >
                {currentUser?.additional_info || "N/A"}
              </Text>
            )}
          </FormControl>


          <Flex mt={4} gap={3}>
            <Button
              variant="primary"
              onClick={toggleEditMode}
              type={editMode ? "button" : "submit"}
              isLoading={editMode ? isSubmitting : false}
              isDisabled={editMode ? !isDirty || !getValues("username") : false}
            >
              {editMode ? "Save" : "Edit"}
            </Button>
            {editMode && (
              <Button onClick={onCancel} isDisabled={isSubmitting}>
                Cancel
              </Button>
            )}
          </Flex>
        </Box>
      </Container>
    </>
  )
}

export default UserInformation

===== ./components/UserSettings/ParseResume.tsx =====
import React, { useState, useEffect } from 'react';
import { Button, FormControl, FormLabel, Select, Slider, SliderTrack, SliderFilledTrack, SliderThumb, useToast, Text, Box, Heading } from '@chakra-ui/react';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { UsersService, ModelNamesService } from '../../client';


const ParseResume: React.FC = () => {
  const queryClient = useQueryClient();
  const [model, setModel] = useState<string>('GPT4_O');
  const [temperature, setTemperature] = useState<number>(0.5);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [modelOptions, setModelOptions] = useState<{ llm_alias: string, llm_value: string }[]>([]);

  const toast = useToast();

  useEffect(() => {
    const fetchModelNames = async () => {
      try {
        const response = await ModelNamesService.getModelNames();
        setModelOptions(response);
        if (response.length > 0) {
          console.log(response)
          setModel(response[0].llm_alias); // Set the first option as the default

        }
      } catch (error) {
        console.error("Error fetching model names:", error);
        toast({
          title: 'Error!',
          description: 'Failed to fetch model names.',
          status: 'error',
          duration: 5000,
          isClosable: true,
        });
      }
    };

    fetchModelNames();
  }, [toast]);


  const mutation = useMutation({
    mutationFn: () => UsersService.parseResume({
      requestBody: {
        name: model,
        temperature: temperature,
      },
    }),
    onMutate: () => {
      setIsLoading(true);
    },
    onSuccess: () => {
      toast({
        title: 'Success!',
        description: 'Resume parsed successfully.',
        status: 'success',
        duration: 5000,
        isClosable: true,
      });
    },
    onError: () => {
      toast({
        title: 'Error!',
        description: 'Failed to parse resume.',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ["users"] })
      queryClient.invalidateQueries({ queryKey: ["currentUser"] })
      setIsLoading(false);

    },

  });

  const handleParse = () => {
    mutation.mutate();
  }
  return (
    <FormControl>
      <Heading as="h3" size="md" mb={4}>Parse your resume using LLMs</Heading>
      <FormLabel>Select Model</FormLabel>
      <Select value={model} onChange={(e) => setModel(e.target.value)}>
        {modelOptions.map(option => (
          <option key={option.llm_value} value={option.llm_alias}>{option.llm_alias}</option>
        ))}
      </Select>
      <FormLabel mt={4}>Set Temperature</FormLabel>
      <Box display="flex" alignItems="center">
        <Slider
          defaultValue={0.5}
          min={0}
          max={2}
          step={0.01}
          value={temperature}
          onChange={(val) => setTemperature(val)}
          flex="1"
          mr={4}
        >
          <SliderTrack>
            <SliderFilledTrack />
          </SliderTrack>
          <SliderThumb />
        </Slider>
        <Text>{temperature.toFixed(2)}</Text>      </Box>
      <Box mt={4} display="flex" alignItems="center">
        <Button onClick={handleParse} isLoading={isLoading} isDisabled={isLoading} mr={4}>Parse Resume</Button>
      </Box>
    </FormControl >
  );
};

export default ParseResume;

===== ./components/UserSettings/ChangePassword.tsx =====
import {
  Box,
  Button,
  Container,
  FormControl,
  FormErrorMessage,
  FormLabel,
  Heading,
  Input,
  useColorModeValue,
} from "@chakra-ui/react"
import { useMutation } from "@tanstack/react-query"
import { type SubmitHandler, useForm } from "react-hook-form"

import { type ApiError, type UpdatePassword, UsersService } from "../../client"
import useCustomToast from "../../hooks/useCustomToast"
import { confirmPasswordRules, passwordRules } from "../../utils"

interface UpdatePasswordForm extends UpdatePassword {
  confirm_password: string
}

const ChangePassword = () => {
  const color = useColorModeValue("inherit", "ui.light")
  const showToast = useCustomToast()
  const {
    register,
    handleSubmit,
    reset,
    getValues,
    formState: { errors, isSubmitting },
  } = useForm<UpdatePasswordForm>({
    mode: "onBlur",
    criteriaMode: "all",
  })

  const mutation = useMutation({
    mutationFn: (data: UpdatePassword) =>
      UsersService.updatePasswordMe({ requestBody: data }),
    onSuccess: () => {
      showToast("Success!", "Password updated.", "success")
      reset()
    },
    onError: (err: ApiError) => {
      const errDetail = (err.body as any)?.detail
      showToast("Something went wrong.", `${errDetail}`, "error")
    },
  })

  const onSubmit: SubmitHandler<UpdatePasswordForm> = async (data) => {
    mutation.mutate(data)
  }

  return (
    <>
      <Container maxW="full" as="form" onSubmit={handleSubmit(onSubmit)}>
        <Heading size="sm" py={4}>
          Change Password
        </Heading>
        <Box w={{ sm: "full", md: "50%" }}>
          <FormControl isRequired isInvalid={!!errors.current_password}>
            <FormLabel color={color} htmlFor="current_password">
              Current password
            </FormLabel>
            <Input
              id="current_password"
              {...register("current_password")}
              placeholder="Password"
              type="password"
            />
            {errors.current_password && (
              <FormErrorMessage>
                {errors.current_password.message}
              </FormErrorMessage>
            )}
          </FormControl>
          <FormControl mt={4} isRequired isInvalid={!!errors.new_password}>
            <FormLabel htmlFor="password">Set Password</FormLabel>
            <Input
              id="password"
              {...register("new_password", passwordRules())}
              placeholder="Password"
              type="password"
            />
            {errors.new_password && (
              <FormErrorMessage>{errors.new_password.message}</FormErrorMessage>
            )}
          </FormControl>
          <FormControl mt={4} isRequired isInvalid={!!errors.confirm_password}>
            <FormLabel htmlFor="confirm_password">Confirm Password</FormLabel>
            <Input
              id="confirm_password"
              {...register("confirm_password", confirmPasswordRules(getValues))}
              placeholder="Password"
              type="password"
            />
            {errors.confirm_password && (
              <FormErrorMessage>
                {errors.confirm_password.message}
              </FormErrorMessage>
            )}
          </FormControl>
          <Button
            variant="primary"
            mt={4}
            type="submit"
            isLoading={isSubmitting}
          >
            Save
          </Button>
        </Box>
      </Container>
    </>
  )
}
export default ChangePassword

===== ./components/UserSettings/DeleteAccount.tsx =====
import {
  Button,
  Container,
  Heading,
  Text,
  useDisclosure,
} from "@chakra-ui/react"

import DeleteConfirmation from "./DeleteConfirmation"

const DeleteAccount = () => {
  const confirmationModal = useDisclosure()

  return (
    <>
      <Container maxW="full">
        <Heading size="sm" py={4}>
          Delete Account
        </Heading>
        <Text>
          Permanently delete your data and everything associated with your
          account.
        </Text>
        <Button variant="danger" mt={4} onClick={confirmationModal.onOpen}>
          Delete
        </Button>
        <DeleteConfirmation
          isOpen={confirmationModal.isOpen}
          onClose={confirmationModal.onClose}
        />
      </Container>
    </>
  )
}
export default DeleteAccount

===== ./components/UserSettings/DeleteConfirmation.tsx =====
import {
  AlertDialog,
  AlertDialogBody,
  AlertDialogContent,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogOverlay,
  Button,
} from "@chakra-ui/react"
import { useMutation, useQueryClient } from "@tanstack/react-query"
import React from "react"
import { useForm } from "react-hook-form"

import { type ApiError, type UserPublicMe, UsersService } from "../../client"
import useAuth from "../../hooks/useAuth"
import useCustomToast from "../../hooks/useCustomToast"

interface DeleteProps {
  isOpen: boolean
  onClose: () => void
}

const DeleteConfirmation = ({ isOpen, onClose }: DeleteProps) => {
  const queryClient = useQueryClient()
  const showToast = useCustomToast()
  const cancelRef = React.useRef<HTMLButtonElement | null>(null)
  const {
    handleSubmit,
    formState: { isSubmitting },
  } = useForm()
  const currentUser = queryClient.getQueryData<UserPublicMe>(["currentUser"])
  const { logout } = useAuth()

  const mutation = useMutation({
    mutationFn: (id: number) => UsersService.deleteUser({ userId: id }),
    onSuccess: () => {
      showToast(
        "Success",
        "Your account has been successfully deleted.",
        "success",
      )
      logout()
      onClose()
    },
    onError: (err: ApiError) => {
      const errDetail = (err.body as any)?.detail
      showToast("Something went wrong.", `${errDetail}`, "error")
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ["currentUser"] })
    },
  })

  const onSubmit = async () => {
    mutation.mutate(currentUser!.id)
  }

  return (
    <>
      <AlertDialog
        isOpen={isOpen}
        onClose={onClose}
        leastDestructiveRef={cancelRef}
        size={{ base: "sm", md: "md" }}
        isCentered
      >
        <AlertDialogOverlay>
          <AlertDialogContent as="form" onSubmit={handleSubmit(onSubmit)}>
            <AlertDialogHeader>Confirmation Required</AlertDialogHeader>

            <AlertDialogBody>
              All your account data will be{" "}
              <strong>permanently deleted.</strong> If you are sure, please
              click <strong>"Confirm"</strong> to proceed. This action cannot be
              undone.
            </AlertDialogBody>

            <AlertDialogFooter gap={3}>
              <Button variant="danger" type="submit" isLoading={isSubmitting}>
                Confirm
              </Button>
              <Button
                ref={cancelRef}
                onClick={onClose}
                isDisabled={isSubmitting}
              >
                Cancel
              </Button>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialogOverlay>
      </AlertDialog>
    </>
  )
}

export default DeleteConfirmation

===== ./components/UserSettings/Appearance.tsx =====
import {
  Badge,
  Container,
  Heading,
  Radio,
  RadioGroup,
  Stack,
  useColorMode,
} from "@chakra-ui/react"

const Appearance = () => {
  const { colorMode, toggleColorMode } = useColorMode()

  return (
    <>
      <Container maxW="full">
        <Heading size="sm" py={4}>
          Appearance
        </Heading>
        <RadioGroup onChange={toggleColorMode} value={colorMode}>
          <Stack>
            {/* TODO: Add system default option */}
            <Radio value="light" colorScheme="teal">
              Light mode
              <Badge ml="1" colorScheme="teal">
                Default
              </Badge>
            </Radio>
            <Radio value="dark" colorScheme="teal">
              Dark mode
            </Radio>
          </Stack>
        </RadioGroup>
      </Container>
    </>
  )
}
export default Appearance

===== ./components/UserSettings/UserCV.tsx =====
import {
  Heading,
  Button,
  Container,
  Flex,
  Box,
} from "@chakra-ui/react"
import { useMutation, useQueryClient } from "@tanstack/react-query"
import { useState } from "react"
import { type SubmitHandler, useForm } from "react-hook-form"

import {
  type ApiError,
  type UserPublicMe,
  type UserUpdateMe,
  UsersService,
} from "../../client"
import useAuth from "../../hooks/useAuth"
import useCustomToast from "../../hooks/useCustomToast"
import ParseResume from "../UserSettings/ParseResume"
import { JsonDisplay } from "../Common/JsonDisplay"
import { PdfDisplay } from "../Common/PdfDisplay"
import { PdfUpload } from "../Common/PdfUpload"

const UserCV = () => {
  const queryClient = useQueryClient()
  const showToast = useCustomToast()
  const [editMode, setEditMode] = useState(false)
  const { user: currentUser } = useAuth()
  const {
    handleSubmit,
    reset,
    getValues,
    formState: { isSubmitting, isDirty },
  } = useForm<UserPublicMe>({
    mode: "onBlur",
    criteriaMode: "all",
    defaultValues: {
      resume: currentUser?.resume,
      parsed_work_experiences: currentUser?.parsed_work_experiences,
      parsed_educations: currentUser?.parsed_educations,
      parsed_languages: currentUser?.parsed_languages,
      parsed_skills: currentUser?.parsed_skills,
      additional_info: currentUser?.additional_info,

    },
  })

  const toggleEditMode = () => {
    setEditMode(!editMode)
  }

  const mutation = useMutation({
    mutationFn: (data: UserUpdateMe) =>
      UsersService.updateUserMe({ requestBody: data }),
    onSuccess: () => {
      showToast("Success!", "User updated successfully.", "success")
    },
    onError: (err: ApiError) => {
      const errDetail = (err.body as any)?.detail
      showToast("Something went wrong.", `${errDetail}`, "error")
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ["users"] })
      queryClient.invalidateQueries({ queryKey: ["currentUser"] })
    },
  })

  const onSubmit: SubmitHandler<UserUpdateMe> = async (data) => {
    mutation.mutate(data)
  }

  const onCancel = () => {
    reset()
    toggleEditMode()
  }

  return (
    <>
      <Container maxW="full" as="form" onSubmit={handleSubmit(onSubmit)}>
        <Flex>

          <Box flex="1">
            <Heading as="h3" size="lg" mb={4}>Upload Your Resume</Heading>
            <PdfUpload />
          </Box>
          <Box flex="1">
            <Heading as="h3" size="lg" mb={4}></Heading>
            <ParseResume />
          </Box>
        </Flex>
        <PdfDisplay base64String={currentUser?.resume ?? null} />


        <JsonDisplay data={JSON.stringify(currentUser?.parsed_work_experiences)} title="Work Experiences" />
        <JsonDisplay data={JSON.stringify(currentUser?.parsed_educations)} title="Educations" />
        <JsonDisplay data={JSON.stringify(currentUser?.parsed_languages)} title="Languages" />
        <JsonDisplay data={JSON.stringify(currentUser?.parsed_skills)} title="Skills" />


        <Flex mt={4} gap={3}>
          <Button
            variant="primary"
            onClick={toggleEditMode}
            type={editMode ? "button" : "submit"}
            isLoading={editMode ? isSubmitting : false}
            isDisabled={editMode ? !isDirty || !getValues("username") : false}
          >
            {editMode ? "Save" : "Edit"}
          </Button>
          {editMode && (
            <Button onClick={onCancel} isDisabled={isSubmitting}>
              Cancel
            </Button>
          )}
        </Flex>
      </Container>
    </>
  )
}

export default UserCV 

===== ./components/Common/Navbar.tsx =====
// import { Button, Flex, Icon, useDisclosure } from "@chakra-ui/react"
// import { FaPlus } from "react-icons/fa"
//
// import AddUser from "../Admin/AddUser"
//
// interface NavbarProps {
//   type: string
// }
//
// const Navbar = ({ type }: NavbarProps) => {
//   const addUserModal = useDisclosure()
//
//   return (
//     <>
//       <Flex py={8} gap={4}>
//         {/* TODO: Complete search functionality */}
//         {/* <InputGroup w={{ base: '100%', md: 'auto' }}>
//                     <InputLeftElement pointerEvents='none'>
//                         <Icon as={FaSearch} color='ui.dim' />
//                     </InputLeftElement>
//                     <Input type='text' placeholder='Search' fontSize={{ base: 'sm', md: 'inherit' }} borderRadius='8px' />
//                 </InputGroup> */}
//         <Button
//           variant="primary"
//           gap={1}
//           fontSize={{ base: "sm", md: "inherit" }}
//           onClick={type === "User" ? addUserModal.onOpen : addUserModal.onOpen}
//         >
//           <Icon as={FaPlus} /> Add {type}
//         </Button>
//         <AddUser isOpen={addUserModal.isOpen} onClose={addUserModal.onClose} />
//       </Flex>
//     </>
//   )
// }
//
// export default Navbar

===== ./components/Common/SidebarItems.tsx =====
import { Box, Flex, Icon, Text, useColorModeValue } from "@chakra-ui/react"
import { useQueryClient } from "@tanstack/react-query"
import { Link } from "@tanstack/react-router"
import { FiBriefcase, FiHome, FiSettings, FiUsers } from "react-icons/fi"

import type { UserPublicMe } from "../../client"

const items = [
  { icon: FiHome, title: "Dashboard", path: "/" },
  { icon: FiBriefcase, title: "Job Postings", path: "/jobpostings" },
  { icon: FiUsers, title: "Applications", path: "/comparisons" },
  { icon: FiSettings, title: "User Settings", path: "/settings" },
]

interface SidebarItemsProps {
  onClose?: () => void
}

const SidebarItems = ({ onClose }: SidebarItemsProps) => {
  const queryClient = useQueryClient()
  const textColor = useColorModeValue("ui.main", "ui.light")
  const bgActive = useColorModeValue("#E2E8F0", "#4A5568")
  const currentUser = queryClient.getQueryData<UserPublicMe>(["currentUser"])

  const finalItems = currentUser?.is_superuser
    ? [...items, { icon: FiUsers, title: "Admin", path: "/admin" }]
    : items

  const listItems = finalItems.map(({ icon, title, path }) => (
    <Flex
      as={Link}
      to={path}
      w="100%"
      p={2}
      key={title}
      activeProps={{
        style: {
          background: bgActive,
          borderRadius: "12px",
        },
      }}
      color={textColor}
      onClick={onClose}
    >
      <Icon as={icon} alignSelf="center" />
      <Text ml={2}>{title}</Text>
    </Flex>
  ))

  return (
    <>
      <Box>{listItems}</Box>
    </>
  )
}

export default SidebarItems

===== ./components/Common/LoadingButton.tsx =====
// export const Button = ({ onClick, text, loading, disabled }) => {
//   return (
//     <button className="submit-btn" onSubmit={onClick} disabled={disabled}>
//       {!loading ? text : 'loading...'}
//     </button>
//   )
// }
//

===== ./components/Common/UserMenu.tsx =====
import {
  Box,
  IconButton,
  Menu,
  MenuButton,
  MenuItem,
  MenuList,
} from "@chakra-ui/react"
import { Link } from "@tanstack/react-router"
import { FaUserAstronaut } from "react-icons/fa"
import { FiLogOut, FiUser } from "react-icons/fi"

import useAuth from "../../hooks/useAuth"

const UserMenu = () => {
  const { logout } = useAuth()

  const handleLogout = async () => {
    logout()
  }

  return (
    <>
      {/* Desktop */}
      <Box
        display={{ base: "none", md: "block" }}
        position="fixed"
        top={4}
        right={4}
      >
        <Menu>
          <MenuButton
            as={IconButton}
            aria-label="Options"
            icon={<FaUserAstronaut color="white" fontSize="18px" />}
            bg="ui.main"
            isRound
          />
          <MenuList>
            <MenuItem icon={<FiUser fontSize="18px" />} as={Link} to="settings">
              My profile
            </MenuItem>
            <MenuItem
              icon={<FiLogOut fontSize="18px" />}
              onClick={handleLogout}
              color="ui.danger"
              fontWeight="bold"
            >
              Log out
            </MenuItem>
          </MenuList>
        </Menu>
      </Box>
    </>
  )
}

export default UserMenu

===== ./components/Common/DeleteAlert.tsx =====
import {
  AlertDialog,
  AlertDialogBody,
  AlertDialogContent,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogOverlay,
  Button,
} from "@chakra-ui/react"
import { useMutation, useQueryClient } from "@tanstack/react-query"
import React from "react"
import { useForm } from "react-hook-form"

import { UsersService } from "../../client"
import useCustomToast from "../../hooks/useCustomToast"

interface DeleteProps {
  type: string
  id: number
  isOpen: boolean
  onClose: () => void
}

const Delete = ({ type, id, isOpen, onClose }: DeleteProps) => {
  const queryClient = useQueryClient()
  const showToast = useCustomToast()
  const cancelRef = React.useRef<HTMLButtonElement | null>(null)
  const {
    handleSubmit,
    formState: { isSubmitting },
  } = useForm()

  const deleteEntity = async (id: number) => {
    if (type === "User") {
      await UsersService.deleteUser({ userId: id })
    } else {
      throw new Error(`Unexpected type: ${type}`)
    }
  }

  const mutation = useMutation({
    mutationFn: deleteEntity,
    onSuccess: () => {
      showToast(
        "Success",
        `The ${type.toLowerCase()} was deleted successfully.`,
        "success",
      )
      onClose()
    },
    onError: () => {
      showToast(
        "An error occurred.",
        `An error occurred while deleting the ${type.toLowerCase()}.`,
        "error",
      )
    },
    onSettled: () => {
      queryClient.invalidateQueries({
        queryKey: [type === "Item" ? "items" : "users"],
      })
    },
  })

  const onSubmit = async () => {
    mutation.mutate(id)
  }

  return (
    <>
      <AlertDialog
        isOpen={isOpen}
        onClose={onClose}
        leastDestructiveRef={cancelRef}
        size={{ base: "sm", md: "md" }}
        isCentered
      >
        <AlertDialogOverlay>
          <AlertDialogContent as="form" onSubmit={handleSubmit(onSubmit)}>
            <AlertDialogHeader>Delete {type}</AlertDialogHeader>

            <AlertDialogBody>
              {type === "User" && (
                <span>
                  All items associated with this user will also be{" "}
                  <strong>permantly deleted. </strong>
                </span>
              )}
              Are you sure? You will not be able to undo this action.
            </AlertDialogBody>

            <AlertDialogFooter gap={3}>
              <Button variant="danger" type="submit" isLoading={isSubmitting}>
                Delete
              </Button>
              <Button
                ref={cancelRef}
                onClick={onClose}
                isDisabled={isSubmitting}
              >
                Cancel
              </Button>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialogOverlay>
      </AlertDialog>
    </>
  )
}

export default Delete

===== ./components/Common/JsonDisplay.tsx =====
import { Box, Code, Heading, useColorModeValue } from '@chakra-ui/react';

type JsonDisplayProps = {
  data: string;
  title?: string;
};

export const JsonDisplay = ({ data, title }: JsonDisplayProps) => {
  // Define colors that adapt to light or dark mode
  const boxBgColor = useColorModeValue('gray.100', 'gray.700');
  const textColor = useColorModeValue('black', 'white');

  return (
    <>
      {title && (
        <Heading size="sm" py={4}>
          {title}
        </Heading>
      )}
      <Box
        p={4}
        bg={boxBgColor} // Dynamically set background color
        color={textColor} // Dynamically set text color
        borderRadius="md"
        overflowX="auto"
      >
        <Code p={2} w="full" display="block" whiteSpace="pre-wrap">
          {JSON.stringify(JSON.parse(data), null, 2)}
        </Code>
      </Box>
    </>
  );
};

===== ./components/Common/ModelTemperatureSelector.tsx =====
import React, { useEffect, useState } from 'react';
import { FormControl, FormLabel, Select, Slider, SliderTrack, SliderFilledTrack, SliderThumb, Box, Text, useToast } from '@chakra-ui/react';
import { ModelNamesService } from '../../client';

interface ModelTemperatureSelectorProps {
  model: string;
  setModel: (model: string) => void;
  temperature: number;
  setTemperature: (temperature: number) => void;
}

const ModelTemperatureSelector: React.FC<ModelTemperatureSelectorProps> = ({ model, setModel, temperature, setTemperature }) => {
  const [modelOptions, setModelOptions] = useState<{ llm_alias: string }[]>([]);
  const toast = useToast();

  useEffect(() => {
    const fetchModelNames = async () => {
      try {
        const response = await ModelNamesService.getModelNames();
        setModelOptions(response.map(model => ({ llm_alias: model.llm_alias })));
        if (response.length > 0) {
          setModel(response[0].llm_alias); // Set the first option as the default
        }
      } catch (error) {
        console.error('Error fetching model names:', error);
        toast({
          title: 'Error!',
          description: 'Failed to fetch model names.',
          status: 'error',
          duration: 5000,
          isClosable: true,
        });
      }
    };

    fetchModelNames();
  }, [toast, setModel]);

  return (
    <FormControl mb={4}>
      <FormLabel>Select Model</FormLabel>
      <Select value={model} onChange={(e) => setModel(e.target.value)}>
        {modelOptions.map(option => (
          <option key={option.llm_alias} value={option.llm_alias}>{option.llm_alias}</option>
        ))}
      </Select>
      <FormLabel mt={4}>Set Temperature</FormLabel>
      <Box display="flex" alignItems="center">
        <Slider
          defaultValue={0.5}
          min={0}
          max={2}
          step={0.01}
          value={temperature}
          onChange={(val) => setTemperature(val)}
          flex="1"
          mr={4}
        >
          <SliderTrack>
            <SliderFilledTrack />
          </SliderTrack>
          <SliderThumb />
        </Slider>
        <Text>{temperature.toFixed(2)}</Text>
      </Box>
    </FormControl>
  );
};

export default ModelTemperatureSelector;


===== ./components/Common/PdfDisplay.tsx =====
import React from 'react';
import { Worker, Viewer } from '@react-pdf-viewer/core';
import '@react-pdf-viewer/core/lib/styles/index.css';
import { Button, Box } from '@chakra-ui/react';
import { DownloadIcon } from '@chakra-ui/icons';

interface PdfDisplayProps {
  base64String: string | null;
  fileName?: string; // New prop for custom file name
}

export const PdfDisplay: React.FC<PdfDisplayProps> = ({ base64String, fileName = 'document.pdf' }) => {
  const pdfBlob = base64String ? `data:application/pdf;base64,${base64String}` : null;

  const sanitizeFileName = (str: string) => {
    return str
      .replace(/[^a-z0-9]/gi, '_') // Replace any character that's not alphanumeric with underscore
      .replace(/_+/g, '_')         // Replace multiple consecutive underscores with a single one
      .toLowerCase()               // Convert to lowercase
      .trim();                     // Remove leading and trailing whitespace
  };

  const sanitizedFileName = sanitizeFileName(fileName);


  const handleDownload = () => {
    if (pdfBlob) {
      const link = document.createElement('a');
      link.href = pdfBlob;
      link.download = sanitizedFileName; // Use the provided fileName or default to 'document.pdf'
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  };

  return (
    <Box>
      <Box mb={4}>
      </Box>
      <Box style={{ width: '100%', height: '70vh', border: '1px solid black' }}>
        {pdfBlob ? (
          <Worker workerUrl="https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js">
            <Viewer fileUrl={pdfBlob} />
          </Worker>
        ) : (
          <p>No PDF available</p>
        )}
      </Box>
      <Button
        leftIcon={<DownloadIcon />}
        onClick={handleDownload}
        isDisabled={!pdfBlob}
      >
        Download {sanitizedFileName} {/* Display the file name in the button text */}
      </Button>
    </Box>
  );
};

===== ./components/Common/ActionsMenu.tsx =====
// import {
//   Button,
//   Menu,
//   MenuButton,
//   MenuItem,
//   MenuList,
//   useDisclosure,
// } from "@chakra-ui/react"
// import { BsThreeDotsVertical } from "react-icons/bs"
// import { FiEdit, FiTrash } from "react-icons/fi"
//
// import type { UserPublicMe } from "../../client"
// // import EditUser from "../Admin/EditUser"
// import Delete from "./DeleteAlert"
//
// interface ActionsMenuProps {
//   type: string
//   value: UserPublicMe
//   disabled?: boolean
// }
//
// const ActionsMenu = ({ type, value, disabled }: ActionsMenuProps) => {
//   const editUserModal = useDisclosure()
//   const deleteModal = useDisclosure()
//
//   return (
//     <>
//       <Menu>
//         <MenuButton
//           isDisabled={disabled}
//           as={Button}
//           rightIcon={<BsThreeDotsVertical />}
//           variant="unstyled"
//         />
//         <MenuList>
//           <MenuItem
//             onClick={editUserModal.onOpen}
//             icon={<FiEdit fontSize="16px" />}
//           >
//             Edit {type}
//           </MenuItem>
//           <MenuItem
//             onClick={deleteModal.onOpen}
//             icon={<FiTrash fontSize="16px" />}
//             color="ui.danger"
//           >
//             Delete {type}
//           </MenuItem>
//         </MenuList>
//         {type === "User" ? (
//           <EditUser
//             user={value as UserPublicMe}
//             isOpen={editUserModal.isOpen}
//             onClose={editUserModal.onClose}
//           />
//         ) : (
//           <EditItem
//             item={value as ItemPublic}
//             isOpen={editUserModal.isOpen}
//             onClose={editUserModal.onClose}
//           />
//         )}
//         <Delete
//           type={type}
//           id={value.id}
//           isOpen={deleteModal.isOpen}
//           onClose={deleteModal.onClose}
//         />
//       </Menu>
//     </>
//   )
// }
//
// export default ActionsMenu

===== ./components/Common/Sidebar.tsx =====
import {
  Box,
  Drawer,
  DrawerBody,
  DrawerCloseButton,
  DrawerContent,
  DrawerOverlay,
  Flex,
  IconButton,
  Image,
  Text,
  useColorModeValue,
  useDisclosure,
} from "@chakra-ui/react"
import { useQueryClient } from "@tanstack/react-query"
import { FiLogOut, FiMenu } from "react-icons/fi"

import Logo from "../../assets/images/fastapi-logo.svg"
import type { UserPublicMe } from "../../client"
import useAuth from "../../hooks/useAuth"
import SidebarItems from "./SidebarItems"

const Sidebar = () => {
  const queryClient = useQueryClient()
  const bgColor = useColorModeValue("ui.light", "ui.dark")
  const textColor = useColorModeValue("ui.dark", "ui.light")
  const secBgColor = useColorModeValue("ui.secondary", "ui.darkSlate")
  const currentUser = queryClient.getQueryData<UserPublicMe>(["currentUser"])
  const { isOpen, onOpen, onClose } = useDisclosure()
  const { logout } = useAuth()

  const handleLogout = async () => {
    logout()
  }

  return (
    <>
      {/* Mobile */}
      <IconButton
        onClick={onOpen}
        display={{ base: "flex", md: "none" }}
        aria-label="Open Menu"
        position="absolute"
        fontSize="20px"
        m={4}
        icon={<FiMenu />}
      />
      <Drawer isOpen={isOpen} placement="left" onClose={onClose}>
        <DrawerOverlay />
        <DrawerContent maxW="250px">
          <DrawerCloseButton />
          <DrawerBody py={8}>
            <Flex flexDir="column" justify="space-between">
              <Box>
                <Image src={Logo} alt="logo" p={6} />
                <SidebarItems onClose={onClose} />
                <Flex
                  as="button"
                  onClick={handleLogout}
                  p={2}
                  color="ui.danger"
                  fontWeight="bold"
                  alignItems="center"
                >
                  <FiLogOut />
                  <Text ml={2}>Log out</Text>
                </Flex>
              </Box>
              {currentUser?.username && (
                <Text color={textColor} noOfLines={2} fontSize="sm" p={2}>
                  Logged in as: {currentUser.username}
                </Text>
              )}
            </Flex>
          </DrawerBody>
        </DrawerContent>
      </Drawer>

      {/* Desktop */}
      <Box
        bg={bgColor}
        p={3}
        h="100vh"
        position="sticky"
        top="0"
        display={{ base: "none", md: "flex" }}
      >
        <Flex
          flexDir="column"
          justify="space-between"
          bg={secBgColor}
          p={4}
          borderRadius={12}
        >
          <Box>
            <Image src={Logo} alt="Logo" w="180px" maxW="2xs" p={6} />
            <SidebarItems />
          </Box>
          {currentUser?.username && (
            <Text
              color={textColor}
              noOfLines={2}
              fontSize="sm"
              p={2}
              maxW="180px"
            >
              Logged in as: {currentUser.username}
            </Text>
          )}
        </Flex>
      </Box>
    </>
  )
}

export default Sidebar

===== ./components/Common/PdfUpload.tsx =====

import React, { useState } from 'react';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import {
  Button,
  FormControl,
  Input,
  useToast,
} from '@chakra-ui/react';
import { UsersService } from '../../client';

export const PdfUpload: React.FC = () => {
  const queryClient = useQueryClient();
  const [file, setFile] = useState<File | null>(null);
  const toast = useToast();

  const mutation = useMutation({
    mutationFn: (formData: FormData) =>
      UsersService.uploadResume({ formData }),
    onSuccess: () => {
      toast({
        title: 'Success!',
        description: 'PDF uploaded successfully.',
        status: 'success',
        duration: 5000,
        isClosable: true,
      });
    },
    onError: () => {
      toast({
        title: 'Error!',
        description: 'Failed to upload PDF.',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ["users"] })
      queryClient.invalidateQueries({ queryKey: ["currentUser"] })
    },

  });

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files;
    if (files && files.length > 0) {
      setFile(files[0]);
    }
  };

  const handleUpload = () => {
    if (file) {
      const formData = new FormData();
      formData.append('file', file);
      mutation.mutate(formData);
      console.log(formData)
    }
  };

  return (
    <FormControl>
      <Input type="file" accept="application/pdf" onChange={handleFileChange} />
      <Button mt={4} onClick={handleUpload} >
        Upload
      </Button>
    </FormControl>
  );
};


===== ./components/Common/NotFound.tsx =====
import { Button, Container, Text } from "@chakra-ui/react"
import { Link } from "@tanstack/react-router"

const NotFound = () => {
  return (
    <>
      <Container
        h="100vh"
        alignItems="stretch"
        justifyContent="center"
        textAlign="center"
        maxW="sm"
        centerContent
      >
        <Text
          fontSize="8xl"
          color="ui.main"
          fontWeight="bold"
          lineHeight="1"
          mb={4}
        >
          404
        </Text>
        <Text fontSize="md">Oops!</Text>
        <Text fontSize="md">Page not found.</Text>
        <Button
          as={Link}
          to="/"
          color="ui.main"
          borderColor="ui.main"
          variant="outline"
          mt={4}
        >
          Go back
        </Button>
      </Container>
    </>
  )
}

export default NotFound

===== ./routes/__root.tsx =====
import { Outlet, createRootRoute } from "@tanstack/react-router"
import React, { Suspense } from "react"

import NotFound from "../components/Common/NotFound"

const TanStackRouterDevtools =
  process.env.NODE_ENV === "production"
    ? () => null
    : React.lazy(() =>
        import("@tanstack/router-devtools").then((res) => ({
          default: res.TanStackRouterDevtools,
        })),
      )

export const Route = createRootRoute({
  component: () => (
    <>
      <Outlet />
      <Suspense>
        <TanStackRouterDevtools />
      </Suspense>
    </>
  ),
  notFoundComponent: () => <NotFound />,
})

===== ./routes/login.tsx =====
import { ViewIcon, ViewOffIcon } from "@chakra-ui/icons"
import {
  Button,
  Center,
  Container,
  FormControl,
  FormErrorMessage,
  Icon,
  Image,
  Input,
  InputGroup,
  InputRightElement,
  Link,
  useBoolean,
} from "@chakra-ui/react"
import {
  Link as RouterLink,
  createFileRoute,
  redirect,
} from "@tanstack/react-router"
import { type SubmitHandler, useForm } from "react-hook-form"

import Logo from "../assets/images/fastapi-logo.svg"
import type { Body_login_login_access_token as AccessToken } from "../client"
import useAuth, { isLoggedIn } from "../hooks/useAuth"
import { emailPattern } from "../utils"

export const Route = createFileRoute("/login")({
  component: Login,
  beforeLoad: async () => {
    if (isLoggedIn()) {
      throw redirect({
        to: "/",
      })
    }
  },
})

function Login() {
  const [show, setShow] = useBoolean()
  const { loginMutation, error, resetError } = useAuth()
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<AccessToken>({
    mode: "onBlur",
    criteriaMode: "all",
    defaultValues: {
      username: "",
      password: "",
    },
  })

  const onSubmit: SubmitHandler<AccessToken> = async (data) => {
    if (isSubmitting) return

    resetError()

    try {
      await loginMutation.mutateAsync(data)
    } catch {
      // error is handled by useAuth hook
    }
  }

  return (
    <>
      <Container
        as="form"
        onSubmit={handleSubmit(onSubmit)}
        h="100vh"
        maxW="sm"
        alignItems="stretch"
        justifyContent="center"
        gap={4}
        centerContent
      >
        <Image
          src={Logo}
          alt="FastAPI logo"
          height="auto"
          maxW="2xs"
          alignSelf="center"
          mb={4}
        />
        <FormControl id="username" isInvalid={!!errors.username || !!error}>
          <Input
            id="username"
            {...register("username", {
              pattern: emailPattern,
            })}
            placeholder="Email"
            type="email"
            required
          />
          {errors.username && (
            <FormErrorMessage>{errors.username.message}</FormErrorMessage>
          )}
        </FormControl>
        <FormControl id="password" isInvalid={!!error}>
          <InputGroup>
            <Input
              {...register("password")}
              type={show ? "text" : "password"}
              placeholder="Password"
              required
            />
            <InputRightElement
              color="ui.dim"
              _hover={{
                cursor: "pointer",
              }}
            >
              <Icon
                onClick={setShow.toggle}
                aria-label={show ? "Hide password" : "Show password"}
              >
                {show ? <ViewOffIcon /> : <ViewIcon />}
              </Icon>
            </InputRightElement>
          </InputGroup>
          {error && <FormErrorMessage>{error}</FormErrorMessage>}
        </FormControl>
        <Center>
          <Link as={RouterLink} to="/recover-password" color="blue.500">
            Forgot password?
          </Link>
        </Center>
        <Button variant="primary" type="submit" isLoading={isSubmitting}>
          Log In
        </Button>
      </Container>
    </>
  )
}

===== ./routes/recover-password.tsx =====
import {
  Button,
  Container,
  FormControl,
  FormErrorMessage,
  Heading,
  Input,
  Text,
} from "@chakra-ui/react"
import { createFileRoute, redirect } from "@tanstack/react-router"
import { type SubmitHandler, useForm } from "react-hook-form"

import { LoginService } from "../client"
import { isLoggedIn } from "../hooks/useAuth"
import useCustomToast from "../hooks/useCustomToast"
import { emailPattern } from "../utils"

interface FormData {
  email: string
}

export const Route = createFileRoute("/recover-password")({
  component: RecoverPassword,
  beforeLoad: async () => {
    if (isLoggedIn()) {
      throw redirect({
        to: "/",
      })
    }
  },
})

function RecoverPassword() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<FormData>()
  const showToast = useCustomToast()

  const onSubmit: SubmitHandler<FormData> = async (data) => {
    await LoginService.recoverPassword({
      email: data.email,
    })
    showToast(
      "Email sent.",
      "We sent an email with a link to get back into your account.",
      "success",
    )
  }

  return (
    <Container
      as="form"
      onSubmit={handleSubmit(onSubmit)}
      h="100vh"
      maxW="sm"
      alignItems="stretch"
      justifyContent="center"
      gap={4}
      centerContent
    >
      <Heading size="xl" color="ui.main" textAlign="center" mb={2}>
        Password Recovery
      </Heading>
      <Text align="center">
        A password recovery email will be sent to the registered account.
      </Text>
      <FormControl isInvalid={!!errors.email}>
        <Input
          id="email"
          {...register("email", {
            required: "Email is required",
            pattern: emailPattern,
          })}
          placeholder="Email"
          type="email"
        />
        {errors.email && (
          <FormErrorMessage>{errors.email.message}</FormErrorMessage>
        )}
      </FormControl>
      <Button variant="primary" type="submit" isLoading={isSubmitting}>
        Continue
      </Button>
    </Container>
  )
}

===== ./routes/_layout/settings.tsx =====
import {
  Container,
  Heading,
  Tab,
  TabList,
  TabPanel,
  TabPanels,
  Tabs,
} from "@chakra-ui/react"
import { useQueryClient } from "@tanstack/react-query"
import { createFileRoute } from "@tanstack/react-router"

import type { UserPublicMe } from "../../client"
import Appearance from "../../components/UserSettings/Appearance"
import ChangePassword from "../../components/UserSettings/ChangePassword"
import DeleteAccount from "../../components/UserSettings/DeleteAccount"
import UserInformation from "../../components/UserSettings/UserInformation"
import UserCV from "../../components/UserSettings/UserCV"

const tabsConfig = [
  { title: "My profile", component: UserInformation },
  { title: "My CV", component: UserCV },
  { title: "Password", component: ChangePassword },
  { title: "Appearance", component: Appearance },
  { title: "Danger zone", component: DeleteAccount },

]

export const Route = createFileRoute("/_layout/settings")({
  component: UserSettings,
})

function UserSettings() {
  const queryClient = useQueryClient()
  const currentUser = queryClient.getQueryData<UserPublicMe>(["currentUser"])
  const finalTabs = currentUser?.is_superuser
    ? tabsConfig.slice(0, 3)
    : tabsConfig

  return (
    <Container maxW="full">
      <Heading size="lg" textAlign={{ base: "center", md: "left" }} py={12}>
        User Settings
      </Heading>
      <Tabs variant="enclosed">
        <TabList>
          {finalTabs.map((tab, index) => (
            <Tab key={index}>{tab.title}</Tab>
          ))}
        </TabList>
        <TabPanels>
          {finalTabs.map((tab, index) => (
            <TabPanel key={index}>
              <tab.component />
            </TabPanel>
          ))}
        </TabPanels>
      </Tabs>
    </Container>
  )
}

===== ./routes/_layout/index.tsx =====
import { Box, Container, Text } from "@chakra-ui/react"
import { useQueryClient } from "@tanstack/react-query"
import { createFileRoute } from "@tanstack/react-router"

import type { UserPublicMe } from "../../client"

export const Route = createFileRoute("/_layout/")({
  component: Dashboard,
})

function Dashboard() {
  const queryClient = useQueryClient()

  const currentUser = queryClient.getQueryData<UserPublicMe>(["currentUser"])

  return (
    <>
      <Container maxW="full">
        <Box pt={12} m={4}>
          <Text fontSize="2xl">
            Hi, {currentUser?.name || currentUser?.username} 👋🏼
          </Text>
          <Text>Welcome back, nice to see you again!</Text>
        </Box>
      </Container>
    </>
  )
}

===== ./routes/_layout/comparisons.tsx =====
import { ChakraProvider } from "@chakra-ui/react";
import { createFileRoute } from "@tanstack/react-router";
import MainLayout from "../../components/comparisons/Layout";

export const Route = createFileRoute("/_layout/comparisons")({
  component: ComparisonsHome,
});

function ComparisonsHome() {
  return (
    <ChakraProvider>
      <MainLayout />
    </ChakraProvider>
  );
}

export default ComparisonsHome;

===== ./routes/_layout/jobpostings.tsx =====
import { useState, useEffect } from "react";
import {
  Container,
  Heading,
  Box,
  ChakraProvider,
  Flex,
  Text,
  Input,
  Button,
  VStack,
} from "@chakra-ui/react";
import { createFileRoute } from "@tanstack/react-router";
import { JobPostingServices, UserComparisonServices } from "../../client/services";
import { JobPostings, JobPosting, UserJobPostingComparison, Message } from "../../client/models";
import JobList from "../../components/JobPostings/JobList";
import JobDetails from "../../components/JobPostings/JobDetails";
import Pagination from "../../components/JobPostings/Pagination"


export const Route = createFileRoute("/_layout/jobpostings")({
  component: JobPostingsHome,
});

function JobPostingsHome() {
  const [selectedJob, setSelectedJob] = useState<JobPosting | null>(null);
  const [jobPostings, setJobPostings] = useState<JobPostings | null>(null);
  const [jobTitle, setJobTitle] = useState<string>("");
  const [companyName, setCompanyName] = useState<string>("");
  const [currentPage, setCurrentPage] = useState<number>(1);
  const [userComparison, setUserComparison] = useState<UserJobPostingComparison | Message | null>(null);
  const limit = 25;

  const fetchJobPostings = async () => {
    try {
      const response = await JobPostingServices.getJobPostings({
        requestBody: {
          skip: limit * (currentPage - 1),
          limit: limit,
          job_title: jobTitle,
          company_name: companyName,
        },
      });
      setJobPostings(response);
    } catch (error) {
      console.error("Error fetching job postings:", error);
    }
  };

  const fetchComparisonStatus = async (ComparisonId: number | null = null, JobPostingId: number | null = null) => {
    if (!ComparisonId && !JobPostingId) {
      console.error("Either ComparisonId or JobPostingId must be provided");
      setUserComparison(null);
      return;
    }
    try {
      const comparison = await UserComparisonServices.getUserComparison({
        comparison_id: ComparisonId,
        job_posting_id: JobPostingId,
      });
      setUserComparison(comparison);
    } catch (error) {
      // Check if the error is a response with a status property
      if (error && typeof error === 'object' && 'status' in error) {
        if (error.status === 404) {
          // Comparison not found
          setUserComparison(null);
          return;
        }
      }
      // Handle other errors
      setUserComparison(null);
      // You might want to set an error state here or handle it differently
    }
  };
  useEffect(() => {
    fetchJobPostings();
  }, [currentPage, jobTitle, companyName]);

  const handleSearch = () => {
    setCurrentPage(1);
    fetchJobPostings();
  };

  const handleJobSelect = (job: JobPosting) => {
    setSelectedJob(job);
    setUserComparison(null);
    fetchComparisonStatus(null, job.id);
  };

  const handleActivateComparison = async (JobPostingId: number) => {
    try {
      // console.log("Activating comparison for job ID:", jobPostingId)

      await UserComparisonServices.activateUserComparison({ job_posting_id: JobPostingId });

      fetchComparisonStatus(null, JobPostingId); // Refresh status
    } catch (error) {
      // console.error("Error activating comparison:", error);
    }
  };

  const handlePageChange = (pageNumber: number) => {
    setCurrentPage(pageNumber);
  }
  return (
    <ChakraProvider>
      <Container maxW="full">
        <Heading size="lg" textAlign={{ base: "center", md: "left" }} py={12}>
          Job Postings
        </Heading>
        <VStack spacing={4} mb={6}>
          <Input
            placeholder="Job Title"
            value={jobTitle}
            onChange={(e) => setJobTitle(e.target.value)}
          />
          <Input
            placeholder="Company Name"
            value={companyName}
            onChange={(e) => setCompanyName(e.target.value)}
          />
          <Button onClick={handleSearch}>Search</Button>
          <Pagination
            currentPage={currentPage}
            onPageChange={handlePageChange}
            totalItems={limit * 10}
            itemsPerPage={limit}
          />

        </VStack>
        <Flex height="100vh">
          <Box width="25%" overflowY="scroll" borderRight="1px solid #ccc">
            {jobPostings && (
              <JobList
                jobPostings={jobPostings}
                onJobSelect={handleJobSelect}
              />
            )}
          </Box>
          <Box width="75%" p={2}>
            {selectedJob ? (
              <>
                <Button
                  onClick={() => handleActivateComparison(selectedJob.id)}
                  disabled={userComparison !== null && 'is_active' in userComparison && userComparison.is_active}
                  mt={4}
                >
                  {userComparison !== null && 'is_active' in userComparison && userComparison.is_active
                    ? "Comparison already active"
                    : "Activate this job for comparison"}
                </Button>

                <JobDetails job={selectedJob} />
              </>
            ) : (
              <Text>Select a job to see details</Text>
            )}
          </Box>
        </Flex>
      </Container>
    </ChakraProvider>
  );
}

===== ./routes/_layout/admin.tsx =====
import {
  Badge,
  Box,
  Container,
  Flex,
  Heading,
  SkeletonText,
  Table,
  TableContainer,
  Tbody,
  Td,
  Th,
  Thead,
  Tr,
} from "@chakra-ui/react"
import { useQueryClient, useSuspenseQuery } from "@tanstack/react-query"
import { createFileRoute } from "@tanstack/react-router"

import { Suspense } from "react"
import { type UserPublicMe, UsersService } from "../../client"
// import ActionsMenu from "../../components/Common/ActionsMenu"

export const Route = createFileRoute("/_layout/admin")({
  component: Admin,
})

const MembersTableBody = () => {
  const queryClient = useQueryClient()
  const currentUser = queryClient.getQueryData<UserPublicMe>(["currentUser"])

  const { data: user } = useSuspenseQuery({
    queryKey: ["user"],
    queryFn: () => UsersService.readUserMe(),
  })

  return (
    <Tbody>
      <Tr key={user.id}>
        <Td color={!user.name ? "ui.dim" : "inherit"}>
          {user.name || "N/A"}
          {currentUser?.id === user.id && (
            <Badge ml="1" colorScheme="teal">
              You
            </Badge>
          )}
        </Td>
        <Td>{user.username}</Td>
        <Td>{user.is_superuser ? "Superuser" : "User"}</Td>
        <Td>
          <Flex gap={2}>
            <Box
              w="2"
              h="2"
              borderRadius="50%"
              bg={user.is_superuser ? "ui.success" : "ui.danger"}
              alignSelf="center"
            />
            {user.is_superuser ? "Active" : "Inactive"}
          </Flex>
        </Td>
        <Td>
          {/* <ActionsMenu */}
          {/*   type="User" */}
          {/*   value={user} */}
          {/*   disabled={currentUser?.id === user.id ? true : false} */}
          {/* /> */}
        </Td>
      </Tr>
    </Tbody>
  )
}

const MembersBodySkeleton = () => {
  return (
    <Tbody>
      <Tr>
        {new Array(5).fill(null).map((_, index) => (
          <Td key={index}>
            <SkeletonText noOfLines={1} paddingBlock="16px" />
          </Td>
        ))}
      </Tr>
    </Tbody>
  )
}

function Admin() {
  return (
    <Container maxW="full">
      <Heading size="lg" textAlign={{ base: "center", md: "left" }} pt={12}>
        User Management
      </Heading>
      <TableContainer>
        <Table fontSize="md" size={{ base: "sm", md: "md" }}>
          <Thead>
            <Tr>
              <Th width="20%">Full name</Th>
              <Th width="50%">Email</Th>
              <Th width="10%">Role</Th>
              <Th width="10%">Status</Th>
              <Th width="10%">Actions</Th>
            </Tr>
          </Thead>
          <Suspense fallback={<MembersBodySkeleton />}>
            <MembersTableBody />
          </Suspense>
        </Table>
      </TableContainer>
    </Container>
  )
}

===== ./routes/reset-password.tsx =====
import {
  Button,
  Container,
  FormControl,
  FormErrorMessage,
  FormLabel,
  Heading,
  Input,
  Text,
} from "@chakra-ui/react"
import { useMutation } from "@tanstack/react-query"
import { createFileRoute, redirect, useNavigate } from "@tanstack/react-router"
import { type SubmitHandler, useForm } from "react-hook-form"

import { type ApiError, LoginService, type NewPassword } from "../client"
import { isLoggedIn } from "../hooks/useAuth"
import useCustomToast from "../hooks/useCustomToast"
import { confirmPasswordRules, passwordRules } from "../utils"

interface NewPasswordForm extends NewPassword {
  confirm_password: string
}

export const Route = createFileRoute("/reset-password")({
  component: ResetPassword,
  beforeLoad: async () => {
    if (isLoggedIn()) {
      throw redirect({
        to: "/",
      })
    }
  },
})

function ResetPassword() {
  const {
    register,
    handleSubmit,
    getValues,
    reset,
    formState: { errors },
  } = useForm<NewPasswordForm>({
    mode: "onBlur",
    criteriaMode: "all",
    defaultValues: {
      new_password: "",
    },
  })
  const showToast = useCustomToast()
  const navigate = useNavigate()

  const resetPassword = async (data: NewPassword) => {
    const token = new URLSearchParams(window.location.search).get("token")
    if (!token) return
    await LoginService.resetPassword({
      requestBody: { new_password: data.new_password, token: token },
    })
  }

  const mutation = useMutation({
    mutationFn: resetPassword,
    onSuccess: () => {
      showToast("Success!", "Password updated.", "success")
      reset()
      navigate({ to: "/login" })
    },
    onError: (err: ApiError) => {
      const errDetail = (err.body as any)?.detail
      showToast("Something went wrong.", `${errDetail}`, "error")
    },
  })

  const onSubmit: SubmitHandler<NewPasswordForm> = async (data) => {
    mutation.mutate(data)
  }

  return (
    <Container
      as="form"
      onSubmit={handleSubmit(onSubmit)}
      h="100vh"
      maxW="sm"
      alignItems="stretch"
      justifyContent="center"
      gap={4}
      centerContent
    >
      <Heading size="xl" color="ui.main" textAlign="center" mb={2}>
        Reset Password
      </Heading>
      <Text textAlign="center">
        Please enter your new password and confirm it to reset your password.
      </Text>
      <FormControl mt={4} isInvalid={!!errors.new_password}>
        <FormLabel htmlFor="password">Set Password</FormLabel>
        <Input
          id="password"
          {...register("new_password", passwordRules())}
          placeholder="Password"
          type="password"
        />
        {errors.new_password && (
          <FormErrorMessage>{errors.new_password.message}</FormErrorMessage>
        )}
      </FormControl>
      <FormControl mt={4} isInvalid={!!errors.confirm_password}>
        <FormLabel htmlFor="confirm_password">Confirm Password</FormLabel>
        <Input
          id="confirm_password"
          {...register("confirm_password", confirmPasswordRules(getValues))}
          placeholder="Password"
          type="password"
        />
        {errors.confirm_password && (
          <FormErrorMessage>{errors.confirm_password.message}</FormErrorMessage>
        )}
      </FormControl>
      <Button variant="primary" type="submit">
        Reset Password
      </Button>
    </Container>
  )
}

===== ./routes/_layout.tsx =====
import { Flex, Spinner } from "@chakra-ui/react"
import { Outlet, createFileRoute, redirect } from "@tanstack/react-router"

import Sidebar from "../components/Common/Sidebar"
import UserMenu from "../components/Common/UserMenu"
import useAuth, { isLoggedIn } from "../hooks/useAuth"

export const Route = createFileRoute("/_layout")({
  component: Layout,
  beforeLoad: async () => {
    if (!isLoggedIn()) {
      throw redirect({
        to: "/login",
      })
    }
  },
})

function Layout() {
  const { isLoading } = useAuth()

  return (
    <Flex maxW="large" h="auto" position="relative">
      <Sidebar />
      {isLoading ? (
        <Flex justify="center" align="center" height="100vh" width="full">
          <Spinner size="xl" color="ui.main" />
        </Flex>
      ) : (
        <Outlet />
      )}
      <UserMenu />
    </Flex>
  )
}

